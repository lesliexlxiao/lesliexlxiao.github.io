[{"categories":["Kubernetes"],"content":"本文主要记录了 k8s 中 pod 无法调度到预期 node 时，如何去进行问题分析。 ","date":"2022-05-27","objectID":"/k8s-pod-schedule-failure/:0:0","tags":["Kubernetes"],"title":"Pod 无法调度到预期 Node 问题分析","uri":"/k8s-pod-schedule-failure/"},{"categories":["Kubernetes"],"content":"1. 背景 目前携程采用的是 gitlabci 去跑 ci 流程。某一天我们通过监控发现，有两台 node 节点始终不能调度到 executor pod。 两台无法调度到 pod 的节点两台无法调度到 pod 的节点 \" 两台无法调度到 pod 的节点 ","date":"2022-05-27","objectID":"/k8s-pod-schedule-failure/:1:0","tags":["Kubernetes"],"title":"Pod 无法调度到预期 Node 问题分析","uri":"/k8s-pod-schedule-failure/"},{"categories":["Kubernetes"],"content":"2. 分析问题 正常情况下 node 被打了污点，而 executor pod 没有配置去容忍该污点，这个时候是没法调度到 node 节点的。但是通过对比分析，pod 已经配置了容忍该污点，仍然无法调度上去。 executor pod 一直在实时生成，node 节点也很多，这个时候我们应该怎么排查问题呢？ 这时，可以 copy 出一份 executor pod yml 文件，修改 pod 名字和 node 名字，然后 apply 该 yml 文件。这个时候我们可以看到该 pod 的状态。 异常 pod异常 pod \" 异常 pod 然后通过 kubectl describe po test-runner-062k8w -n gitlabci 命令查看具体报错原因： pod detail errorpod detail erro \" pod detail error 最终发现是 node 上一个插件有问题，导致调度的时候无法判断还有没有可用 IP。 ","date":"2022-05-27","objectID":"/k8s-pod-schedule-failure/:2:0","tags":["Kubernetes"],"title":"Pod 无法调度到预期 Node 问题分析","uri":"/k8s-pod-schedule-failure/"},{"categories":["Kubernetes"],"content":"3. 解决问题 重启 node 有问题插件，调度成功。 两台调度成功的节点两台调度成功的节点 \" 两台调度成功的节点 ","date":"2022-05-27","objectID":"/k8s-pod-schedule-failure/:3:0","tags":["Kubernetes"],"title":"Pod 无法调度到预期 Node 问题分析","uri":"/k8s-pod-schedule-failure/"},{"categories":["Jenkins"],"content":"本文主要介绍了 Jenkins 的一些常用插件。 ","date":"2022-04-26","objectID":"/jenkins-common-plugins/:0:0","tags":["Jenkins"],"title":"Jenkins 常用插件介绍","uri":"/jenkins-common-plugins/"},{"categories":["Jenkins"],"content":"1. 常用插件介绍 ","date":"2022-04-26","objectID":"/jenkins-common-plugins/:1:0","tags":["Jenkins"],"title":"Jenkins 常用插件介绍","uri":"/jenkins-common-plugins/"},{"categories":["Jenkins"],"content":"1.1 CAS Plugin 用于 CAS 接入。 CAS 插件介绍CAS 插件介绍 \" CAS 插件介绍 CAS 插件配置CAS 插件配置 \" CAS 插件配置 ","date":"2022-04-26","objectID":"/jenkins-common-plugins/:1:1","tags":["Jenkins"],"title":"Jenkins 常用插件介绍","uri":"/jenkins-common-plugins/"},{"categories":["Jenkins"],"content":"1.2 Matrix Authorization Strategy Plugin Matrix Authorization 插件介绍Matrix Authorization 插件介绍 \" Matrix Authorization 插件介绍 Matrix Authorization 插件配置Matrix Authorization 插件配置 \" Matrix Authorization 插件配置 ","date":"2022-04-26","objectID":"/jenkins-common-plugins/:1:2","tags":["Jenkins"],"title":"Jenkins 常用插件介绍","uri":"/jenkins-common-plugins/"},{"categories":["Jenkins"],"content":"1.3 Pipeline Plugin 用来创建 Pipeline Job。如果不配置，创建 Job 时将不会有下面的选项。 创建 Pipeline Job创建 Pipeline Job \" 创建 Pipeline Job ","date":"2022-04-26","objectID":"/jenkins-common-plugins/:1:3","tags":["Jenkins"],"title":"Jenkins 常用插件介绍","uri":"/jenkins-common-plugins/"},{"categories":["Jenkins"],"content":"1.4 Timestamper Plugin Adds timestamps to the Console Output，没有装该插件的报错如下： Timestamper 插件报错Timestamper 插件报错 \" Timestamper 插件报错 ","date":"2022-04-26","objectID":"/jenkins-common-plugins/:1:4","tags":["Jenkins"],"title":"Jenkins 常用插件介绍","uri":"/jenkins-common-plugins/"},{"categories":["Jenkins"],"content":"1.5 Pipeline Utility Steps Plugin Utility steps for pipeline jobs，没有装该插件的报错如下： Pipeline Utility Steps 插件报错Pipeline Utility Steps 插件报错 \" Pipeline Utility Steps 插件报错 ","date":"2022-04-26","objectID":"/jenkins-common-plugins/:1:5","tags":["Jenkins"],"title":"Jenkins 常用插件介绍","uri":"/jenkins-common-plugins/"},{"categories":["Jenkins"],"content":"1.6 Git Plugin This plugin integrates Git with Jenkins，如果不配置，Pipeline script from SCM 时无法选择到 git： Git 插件配置Git 插件配置 \" Git 插件配置 ","date":"2022-04-26","objectID":"/jenkins-common-plugins/:1:6","tags":["Jenkins"],"title":"Jenkins 常用插件介绍","uri":"/jenkins-common-plugins/"},{"categories":["Jenkins"],"content":"1.7 Kubernetes Plugin This plugin integrates Jenkins with kubernetes。 Kubernetes 插件介绍Kubernetes 插件介绍 \" Kubernetes 插件介绍 Kubernetes 插件配置步骤 1Kubernetes 插件配置步骤 1 \" Kubernetes 插件配置步骤 1 Kubernetes 插件配置步骤 2Kubernetes 插件配置步骤 2 \" Kubernetes 插件配置步骤 2 Kubernetes 插件配置步骤 3Kubernetes 插件配置步骤 3 \" Kubernetes 插件配置步骤 3 Kubernetes 插件配置步骤 4Kubernetes 插件配置步骤 4 \" Kubernetes 插件配置步骤 4 Kubernetes 插件配置步骤 5Kubernetes 插件配置步骤 5 \" Kubernetes 插件配置步骤 5 ","date":"2022-04-26","objectID":"/jenkins-common-plugins/:2:0","tags":["Jenkins"],"title":"Jenkins 常用插件介绍","uri":"/jenkins-common-plugins/"},{"categories":["Jenkins"],"content":"2. 携程 build 使用的插件 主要包括：CAS、Matrix Authorization Strategy、Pipeline、Timestamper、Pipeline Utility Steps、Git、Kubernetes 等。 ","date":"2022-04-26","objectID":"/jenkins-common-plugins/:3:0","tags":["Jenkins"],"title":"Jenkins 常用插件介绍","uri":"/jenkins-common-plugins/"},{"categories":["Docker"],"content":"本文主要介绍了 Docker 的多阶段构建，以及多阶段构建的一些优势。 Docker 17.05 之前的版本是不支持 multi-stage 镜像构建，通常会采用两种方式构建。一种是全部放入一个 Dockerfile 文件中构建，一种是分散到多个 Dockerfile 文件中构建。 ","date":"2022-03-24","objectID":"/docker-multi-stage-build/:0:0","tags":["Docker"],"title":"Docker 多阶段构建","uri":"/docker-multi-stage-build/"},{"categories":["Docker"],"content":"1. 单 Dockerfile 构建 这种方式会将项目及其依赖库的编译、测试、打包的所有构建过程放到一个 Dockerfile 中。示例如下： app.go 文件 package main import \"fmt\" func main() { fmt.Printf(\"Hello World!\\n\"); } Dockerfile.one 文件 FROM golang:1.9-alpine WORKDIR /var/www/code/go/ COPY app.go . RUN go build app.go CMD [\"./app\"] 构建镜像 $ docker build -t go/helloworld:v1 -f Dockerfile.one . ----------output---------- Sending build context to Docker daemon 3.072kB Step 1/5 : FROM golang:1.9-alpine ---\u003e b0260be938c6 Step 2/5 : WORKDIR /var/www/code/go/ Removing intermediate container e5fdc95ae667 ---\u003e bf72ca2f4c1e Step 3/5 : COPY app.go . ---\u003e 4303ab391236 Step 4/5 : RUN go build app.go ---\u003e Running in 61ff23d31be3 Removing intermediate container 61ff23d31be3 ---\u003e 00924c2d8fea Step 5/5 : CMD [\"./app\"] ---\u003e Running in bc84752fea13 Removing intermediate container bc84752fea13 ---\u003e 3360ad3ce4f1 Successfully built 3360ad3ce4f1 Successfully tagged go/helloworld:v1 这种构建方式存在的问题： Dockerfile 过长（包括一系列编译、测试、打包过程），可维护性降低。 镜像层次多，增加构建时长。因为打镜像时每一层都会起容器执行一些命令，如果层级过多镜像会非常臃肿且构建时间变长2。 如上例中的 COPY 源码，构建源码都会增加镜像的层级。 镜像体积较大，部署时间变长。 镜像体积大，可以看到该 Dockerfile 构建出的镜像有 242M。 镜像构建大小镜像构建大小 \" 镜像构建大小 源代码存在泄漏风险。 这是由于构建出的镜像里面包含了源代码，可以通过如下命令查看： $ docker run --rm go/helloworld:v1 ls ----------output---------- app.go app 可以看到包含了源代码 app.go 文件。 ","date":"2022-03-24","objectID":"/docker-multi-stage-build/:1:0","tags":["Docker"],"title":"Docker 多阶段构建","uri":"/docker-multi-stage-build/"},{"categories":["Docker"],"content":"2. 多 Dockerfile 构建 这种方式主要是把镜像过程分散到多个 Dockerfile 中。主要实现方法是事先在一个 Dockerfile 将项目及其依赖库编译测试打包好，再将包拷贝到运行环境中。这种方式需要两个 Dockerfile 和一段编译脚本才可实现。示例如下： Dockerfile.build 文件 FROM golang:1.9-alpine WORKDIR /var/www/code/go/ COPY app.go . RUN go build app.go Dockerfile.run 文件 FROM alpine:latest WORKDIR /var/www/code/go/ COPY app . CMD [\"./app\"] build.sh 文件 #!/bin/sh echo Building go/helloworld:build docker build -t go/helloworld:build -f Dockerfile.build . # create temporary container docker create --name extract go/helloworld:build # extract app docker cp extract:/var/www/code/go/app ./app # remove temporary container docker rm -f extract echo Building go/helloworld:v2 docker build --no-cache -t go/helloworld:v2 . -f Dockerfile.run rm ./app 运行脚本 $ chmod +x build.sh $ ./build.sh 如果分散多个 Dockerfile 会存在如下问题： 部署过程复杂，一旦涉及到的 Dockerfile 过多，整合比较容易出错。 当然这种方式也有自己的优势： 将这种方式和第一种方式生成的镜像做下比较，如下图所示镜像 v2 的要比镜像 v1 小很多。 镜像构建大小镜像构建大小 \" 镜像构建大小 这是因为镜像 v1 需要的基础镜像 golang:1.9-alpine 比镜像 v2 需要的基础镜像 alpine:latest 要大的多。 镜像构建大小镜像构建大小 \" 镜像构建大小 ","date":"2022-03-24","objectID":"/docker-multi-stage-build/:2:0","tags":["Docker"],"title":"Docker 多阶段构建","uri":"/docker-multi-stage-build/"},{"categories":["Docker"],"content":"3. multi-stage 镜像构建 Dockerfile v17.05 开始支持多阶段构建( multi-stage builds )，只需要一个 Dockerfile。示例如下： Dockerfile.three FROM golang:1.9-alpine as builder WORKDIR /var/www/code/go/ COPY app.go . RUN go build app.go FROM alpine:latest as prod WORKDIR /var/www/code/go/ COPY --from=0 /var/www/code/go/ . CMD [\"./app\"] 构建镜像 $ docker build -t go/helloworld:v3 . ----------output---------- Sending build context to Docker daemon 7.168kB Step 1/8 : FROM golang:1.9-alpine as builder ---\u003e b0260be938c6 Step 2/8 : WORKDIR /var/www/code/go/ ---\u003e Using cache ---\u003e bf72ca2f4c1e Step 3/8 : COPY app.go . ---\u003e Using cache ---\u003e 4303ab391236 Step 4/8 : RUN go build app.go ---\u003e Using cache ---\u003e 00924c2d8fea Step 5/8 : FROM alpine:latest as prod ---\u003e 5cb3aa00f899 Step 6/8 : WORKDIR /var/www/code/go/ ---\u003e Using cache ---\u003e 328cf5fcaaf2 Step 7/8 : COPY --from=0 /var/www/code/go/ . ---\u003e eab42f02e484 Step 8/8 : CMD [\"./app\"] ---\u003e Running in f8a42b2f9a14 Removing intermediate container f8a42b2f9a14 ---\u003e 81ec45b799db Successfully built 81ec45b799db Successfully tagged go/helloworld:v3 这种构建方式的优势： 解决了上述第一种方式和第二种方式存在的弊端。 镜像体积大小对比如下: 镜像体积大小对比镜像体积大小对比 \" 镜像体积大小对比 ","date":"2022-03-24","objectID":"/docker-multi-stage-build/:3:0","tags":["Docker"],"title":"Docker 多阶段构建","uri":"/docker-multi-stage-build/"},{"categories":["Docker"],"content":"4. 只构建某一阶段的镜像 使用 as 来为某一阶段命名 FROM golang:1.9-alpine as builder 以上述例子为例，只想构建 builder 阶段的镜像时，可以在 docker build 命令时加上 –target 参数 $ docker build --target builder -t username/imagename:tag . ","date":"2022-03-24","objectID":"/docker-multi-stage-build/:4:0","tags":["Docker"],"title":"Docker 多阶段构建","uri":"/docker-multi-stage-build/"},{"categories":["Docker"],"content":"5. 构建时从其他镜像复制文件 从上一阶段镜像中复制文件 COPY --from=0 /go/src/github.com/go/helloworld/app . 指定 –from=0 参数，把前一阶段构建的产物拷贝到了当前的镜像中。 COPY --from=builder /go/src/github.com/go/helloworld/app . 指定 –from=builder 参数，把命名阶段的构建产物拷贝到当前的镜像中。 复制任意镜像中的文件 COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf ","date":"2022-03-24","objectID":"/docker-multi-stage-build/:5:0","tags":["Docker"],"title":"Docker 多阶段构建","uri":"/docker-multi-stage-build/"},{"categories":["Docker"],"content":"6. 参考文献 [1] yeasy.Docker 从入门到实践[M]:98-104. [2] 使用 Dockerfile 定制镜像[N].https://www.dazhuanlan.com/2020/02/22/5e51368ed08e7/. [3] 孙宏亮.深刻理解 Docker 镜像大小[N].https://blog.csdn.net/shlazww/article/details/47375009. ","date":"2022-03-24","objectID":"/docker-multi-stage-build/:6:0","tags":["Docker"],"title":"Docker 多阶段构建","uri":"/docker-multi-stage-build/"},{"categories":["Docker"],"content":"本文主要介绍了编写 Dockerfile 指令相关的一些最佳实践。 ","date":"2022-03-24","objectID":"/docker-dockerfile-bp2/:0:0","tags":["Docker"],"title":"Dockerfile 最佳实践（指令相关）","uri":"/docker-dockerfile-bp2/"},{"categories":["Docker"],"content":"1. FROM 尽可能使用当前官方仓库作为你构建镜像的基础。如果公司内部使用，可下载官方仓库镜像，再推送至私有 registry。 推荐使用 Alpine 镜像（Alpine Linux 是一个完整的操作系统），因为其被严格控制并保持在最小尺寸（目前大小 5.52M）。基于此基础镜像，再去构建自己的基础镜像，可以有效控制镜像的大小。 ","date":"2022-03-24","objectID":"/docker-dockerfile-bp2/:1:0","tags":["Docker"],"title":"Dockerfile 最佳实践（指令相关）","uri":"/docker-dockerfile-bp2/"},{"categories":["Docker"],"content":"2. LABEL 通过给镜像添加标签可以帮助组织镜像、记录许可信息、辅助自动化构建等。示例如下： LABEL com.example.version=\"0.0.1-beta\" LABEL vendor=\"ACME Incorporated\" LABEL com.example.release-date=\"2015-02-12\" LABEL com.example.version.is-production=\"\" 注意：如果你的字符串中包含空格，必须将字符串放入引号中或者对空格使用转义。如果字符串内容本身就包含引号，必须对引号使用转义。 一个镜像可以包含多个标签，但建议将多个标签放入到一个 LABEL 指令中。 LABEL vendor=ACME\\ Incorporated \\ com.example.is-beta= \\ com.example.is-production=\"\" \\ com.example.version=\"0.0.1-beta\" \\ com.example.release-date=\"2015-02-12\" 标签可接受的键值参考：Understanding object labels 查询标签信息参考：Managing labels on objects 在实际运维过程中，容器的数量级一旦上升，就会给运维上带来很大的挑战。通过 label 可以很好的将容器分类，从而便于运维。 # 创建容器的时候定义一个 label，表示该容器在 test 这个区域 $ docker run -itd --name nginx-test --label zone=test # 使用自定义的 label 快速检索容器，并进行下一步操作 $ docker ps -f label=zone=test --format='{{.NAMES}}' ","date":"2022-03-24","objectID":"/docker-dockerfile-bp2/:2:0","tags":["Docker"],"title":"Dockerfile 最佳实践（指令相关）","uri":"/docker-dockerfile-bp2/"},{"categories":["Docker"],"content":"3. RUN 为了保持 Dockerfile 文件的可读性，可理解性，以及可维护性，过长的或复杂的 RUN 指令使用反斜杠 \\ 分行。 RUN yum install -y pip \\ git-1.9.3.1 \\ wget-1.14 \u0026\u0026 \\ yum clean all Ubuntu，通常会使用 apt-get 去安装包。 不要使用 RUN apt-get upgrade 或 dist-upgrade，因为 upgrade 命令会导致升级所有包，其实常常用户并不想升级基础镜像里面的包。如果要单独升级某一个包，使用 apt-get install -y foo。 将 RUN apt-get update 和 apt-get install 组合成一条 RUN 声明： RUN apt-get update \u0026\u0026 apt-get install -y \\ package-bar \\ package-baz 如果将 RUN apt-get update 和 apt-get install 拆解为两条命令，会导致缓存问题记忆后续的 install 失败，示例如下： FROM ubuntu:14.04 RUN apt-get update RUN apt-get install -y curl 构建镜像后，所有的镜像层都在 Docker 缓存中。这时修改 Dockerfile 如下： FROM ubuntu:14.04 RUN apt-get update RUN apt-get install -y curl nginx 再次构建镜像，Docker 发现 RUN apt-get update 指令一样。这样会导致 apt-get update 不再执行，使用缓存镜像。后面使用 apt-get install 安装的是过时的 curl 和 nginx 版本。 ","date":"2022-03-24","objectID":"/docker-dockerfile-bp2/:3:0","tags":["Docker"],"title":"Dockerfile 最佳实践（指令相关）","uri":"/docker-dockerfile-bp2/"},{"categories":["Docker"],"content":"4. CMD 多数情况下都应该以 CMD [“executable”, “param1”, “param2”…] 的形式使用。 极少情况下才能以 CMD [“param”, “param”] 的形式与 ENTRYPOINT 协同使用。 ","date":"2022-03-24","objectID":"/docker-dockerfile-bp2/:4:0","tags":["Docker"],"title":"Dockerfile 最佳实践（指令相关）","uri":"/docker-dockerfile-bp2/"},{"categories":["Docker"],"content":"5. EXPOSE 为应用程序 EXPOSE 常用端口，如 Apache web 服务的镜像使用 EXPOSE 80，MongoDB 服务的镜像使用 EXPOSE 27017。 ","date":"2022-03-24","objectID":"/docker-dockerfile-bp2/:5:0","tags":["Docker"],"title":"Dockerfile 最佳实践（指令相关）","uri":"/docker-dockerfile-bp2/"},{"categories":["Docker"],"content":"6. ENV 主要有以下作用： 为容器中安装的程序更新 PATH 环境变量，确保如 CMD [“nginx”] 正确运行。 ENV PATH /usr/local/nginx/bin:$PATH 为容器化服务提供必要的环境变量。 ","date":"2022-03-24","objectID":"/docker-dockerfile-bp2/:6:0","tags":["Docker"],"title":"Dockerfile 最佳实践（指令相关）","uri":"/docker-dockerfile-bp2/"},{"categories":["Docker"],"content":"7. ADD 和 COPY 优先使用 COPY，COPY 语义更明确。 ADD 能够将本地 tar 文件自动提取到镜像中，这种场景用 ADD 更合适。 如果 Dockerfile 中需要 COPY 多个上下文中的文件，不要一次性 COPY 所有文件，这将保证每个步骤的构建缓存只在特定的文件变化时失效。最好的做法是按文件组织结构以及功能去 COPY 文件。 为了让镜像尽量小，最好不要使用 ADD 指令从远程 URL 获取包，而是使用 curl 和 wget 。这样可以避免使用 ADD 而会多出的额外镜像层，示例如下： # invalid method ADD http://example.com/big.tar.xz /usr/src/things/ RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/things \u0026\u0026 \\ make -C /usr/src/things all # valid method RUN mkdir -p /usr/src/things \\ \u0026\u0026 curl -SL http://example.com/big.tar.xz \\ | tar -xJC /usr/src/things \\ \u0026\u0026 make -C /usr/src/things all 可以看出第一种方法会比第二种方法多出额外的镜像层。 ","date":"2022-03-24","objectID":"/docker-dockerfile-bp2/:7:0","tags":["Docker"],"title":"Dockerfile 最佳实践（指令相关）","uri":"/docker-dockerfile-bp2/"},{"categories":["Docker"],"content":"8. ENTRYPOINT 最佳用处是设置镜像的主命令，允许将镜像当成命令本身来运行。示例如下： ENTRYPOINT [\"s3cmd\"] CMD [\"--help\"] 运行容器： $ docker run s3cmd $ docker run s3cmd ls s3://mybucket 将 ENTRYPOINT 指令结合一个辅助脚本使用，去解决容器启动中多步骤问题。 例如，Postgres 官方镜像使用下面的脚本作为 ENTRYPOINT: #!/bin/bash set -e if [ \"$1\" = 'postgres' ]; then chown -R postgres \"$PGDATA\" if [ -z \"$(ls -A \"$PGDATA\")\" ]; then gosu postgres initdb fi exec gosu postgres \"$@\" fi exec \"$@\" 注意： 该脚本使用了 Bash 的内置命令 exec，所以最后运行的进程就是容器的 PID 为 1 的进程。这样，进程就可以接收到任何发送给容器的 Unix 信号了。 该辅助脚本被拷贝到容器，并在容器启动时通过 ENTRYPOINT 执行: COPY ./docker-entrypoint.sh / ENTRYPOINT [\"/docker-entrypoint.sh\"] 这样可以使用多种方式和 postgres 交互： # 简单启动 Postgres $ docker run postgres # 执行 Postgres 并传递参数 $ docker run postgres postgres --help ","date":"2022-03-24","objectID":"/docker-dockerfile-bp2/:8:0","tags":["Docker"],"title":"Dockerfile 最佳实践（指令相关）","uri":"/docker-dockerfile-bp2/"},{"categories":["Docker"],"content":"9. VOLUME 建议使用 VOLUME 来管理镜像中的可变部分和用户可以改变的部分，如数据库存储文件、配置文件、容器创建的文件和目录等。 ","date":"2022-03-24","objectID":"/docker-dockerfile-bp2/:9:0","tags":["Docker"],"title":"Dockerfile 最佳实践（指令相关）","uri":"/docker-dockerfile-bp2/"},{"categories":["Docker"],"content":"10. USER 不需要使用特权执行的服务，建议使用 USER 指令切换到非 root 用户。使用下面的方法创建用户和用户组： RUN groupadd -r postgres \u0026\u0026 \\ useradd -r -g postgres postgres 避免使用 sudo，因为它可预期的 TTY 和信号转发行为可能造成很多问题。可以使用 gosu 来替代 sudo。 为了减少层数和复杂度，避免频繁地使用 USER 来回切换用户。 ","date":"2022-03-24","objectID":"/docker-dockerfile-bp2/:10:0","tags":["Docker"],"title":"Dockerfile 最佳实践（指令相关）","uri":"/docker-dockerfile-bp2/"},{"categories":["Docker"],"content":"11. WORKDIR 为了清晰性和可靠性，应该总是在 WORKDIR 中使用绝对路径 使用 WORKDIR 来替代类似于 RUN cd … \u0026\u0026 do-something 的指令，后者难以阅读、排错和维护。 ","date":"2022-03-24","objectID":"/docker-dockerfile-bp2/:11:0","tags":["Docker"],"title":"Dockerfile 最佳实践（指令相关）","uri":"/docker-dockerfile-bp2/"},{"categories":["Docker"],"content":"12. 参考文献 [1] yeasy.Docker 从入门到实践[M]:369-375. [2] 廖煜,晏东.Docker 容器实战[M].北京:电子工业出版社,2016:183-199. ","date":"2022-03-24","objectID":"/docker-dockerfile-bp2/:12:0","tags":["Docker"],"title":"Dockerfile 最佳实践（指令相关）","uri":"/docker-dockerfile-bp2/"},{"categories":["Docker"],"content":"本文主要介绍了编写 Dockerfile 时的一些最佳实践，主要包括一些常规指南和建议。 ","date":"2022-03-24","objectID":"/docker-dockerfile-bp1/:0:0","tags":["Docker"],"title":"Dockerfile 最佳实践（常规指南和建议）","uri":"/docker-dockerfile-bp1/"},{"categories":["Docker"],"content":"1. 忽略 docker build 构建文件 在 docker build 的过程中，首先会将指定的上下文目录打包传递给 docker 引擎，而这个上下文目录中可能并不是所有的文件我们都会在 Dockerfile 中使用到，那么这个时候就可以在 .dockerignore 文件中指定在传递给 docker 引擎时需要忽略掉的文件或文件夹。 .dockerignore 使用方法和 Git 的 .gitignore 使用方法相似。 ","date":"2022-03-24","objectID":"/docker-dockerfile-bp1/:1:0","tags":["Docker"],"title":"Dockerfile 最佳实践（常规指南和建议）","uri":"/docker-dockerfile-bp1/"},{"categories":["Docker"],"content":"2. 使用多阶段构建 Docker 17.05 以上的版本支持多阶段构建。 多阶段构建能够有效减少构建镜像的大小。 关于多阶段构建的优势可以参考： Docker 多阶段构建。 ","date":"2022-03-24","objectID":"/docker-dockerfile-bp1/:2:0","tags":["Docker"],"title":"Dockerfile 最佳实践（常规指南和建议）","uri":"/docker-dockerfile-bp1/"},{"categories":["Docker"],"content":"3. 避免安装不必要的包 安装不必要的包会带来以下问题： 增加了构建镜像的时间。 构建出的镜像会变得比较臃肿。 ","date":"2022-03-24","objectID":"/docker-dockerfile-bp1/:3:0","tags":["Docker"],"title":"Dockerfile 最佳实践（常规指南和建议）","uri":"/docker-dockerfile-bp1/"},{"categories":["Docker"],"content":"4. 一个容器只运行一个进程 确保一个容器只运行一个进程。将多个应用解耦到不同的容器中，这样能够确保容器的横向扩展和复用。例如可以将一个 WEB 应用拆分为三个容器：WEB 应用 、数据库、缓存。 如果不拆分为三个容器，会带来什么问题。请看下图，横向扩展之后，数据库和缓存均被扩展为了多份，这是不合理的。 容器不拆分容器不拆分 \" 容器不拆分 如果拆分为三个容器，那么扩展 WEB 应用，就会变得方便许多。如下图所示： 容器拆分容器拆分 \" 容器拆分 ","date":"2022-03-24","objectID":"/docker-dockerfile-bp1/:4:0","tags":["Docker"],"title":"Dockerfile 最佳实践（常规指南和建议）","uri":"/docker-dockerfile-bp1/"},{"categories":["Docker"],"content":"5. 镜像层数尽可能少 需要在 Dockerfile 可读性、长期可维护性和减少层数之间做一个平衡。 如果一味的为了可读性而不加控制的增加镜像层数，最后会导致镜像层级增多，镜像的构建速度会变得很慢。 如果一味的为了减少镜像层数，而将多个操作放置到镜像某一层去做，这样 Dockerfile 的可读性会变得很差，导致后期无法维护。 ","date":"2022-03-24","objectID":"/docker-dockerfile-bp1/:5:0","tags":["Docker"],"title":"Dockerfile 最佳实践（常规指南和建议）","uri":"/docker-dockerfile-bp1/"},{"categories":["Docker"],"content":"6. 将多行参数排序 多行参数按字母顺序排序，可以避免重复包含同一个包，更新包列表时也更容易。反斜杠符号 \\ 之前添加一个空格，以增加可读性。示例如下： RUN apt-get update \u0026\u0026 apt-get install -y \\ curl=7.47.0-1ubuntu2.11 \\ openssh-client=1:7.2p2-4ubuntu2.6 \\ openssh-server=1:7.2p2-4ubuntu2.6 \\ sudo=1.8.16-0ubuntu1.5 \\ telnet=0.17-40 ","date":"2022-03-24","objectID":"/docker-dockerfile-bp1/:6:0","tags":["Docker"],"title":"Dockerfile 最佳实践（常规指南和建议）","uri":"/docker-dockerfile-bp1/"},{"categories":["Docker"],"content":"7. 清除缓存的包 缓存的包往往会增加镜像的体积，这样就会导致镜像下载速度变慢。对于无用的缓存，应当及时清理。 RUN apt-get update \u0026\u0026 apt-get install -y \\ curl=7.47.0-1ubuntu2.11 \\ openssh-client=1:7.2p2-4ubuntu2.6 \\ openssh-server=1:7.2p2-4ubuntu2.6 \\ sudo=1.8.16-0ubuntu1.5 \\ telnet=0.17-40 \u0026\u0026 \\ apt-get clean 如上，apt-get clean 用于清除已缓存的包文件。 RUN yum install -y net-tools-2.0 \\ vim-enhanced-7.4.160 \u0026\u0026 \\ yum clean all 如上，yum clean all 用于清除 yum 缓存。 安装包时，带上版本号，确保重新构建镜像时，构建出的镜像是一致的。 ","date":"2022-03-24","objectID":"/docker-dockerfile-bp1/:7:0","tags":["Docker"],"title":"Dockerfile 最佳实践（常规指南和建议）","uri":"/docker-dockerfile-bp1/"},{"categories":["Docker"],"content":"8. 充分利用构建缓存 Docker 在执行每条 Dockerfile 指令之前，都会在缓存中查找是否已经存在可重复的镜像，如果有，将不再重复创建。 缓存的匹配规则：从基础镜像开始，下一条指令将和该基础镜像的所有子镜像进行匹配，检查这些子镜像被创建时使用的指令是否和被检查的指令完全一样。如果不是，则缓存失效。 示例如下： 第一步，初始 Dockerfile 文件如下： FROMcentosRUN echo hello1 第二步，构建镜像： $ docker build . -t centos-hello1 ----------output---------- Step 1/2 : FROM centos ---\u003e 9f38484d220f Step 2/2 : RUN echo hello1 ---\u003e Running in 7285c267446d hello1 Removing intermediate container 7285c267446d ---\u003e d5e9279556bb Successfully built d5e9279556bb Successfully tagged centos-hello1:latest 这一步构建出了镜像 d5e9279556bb。 第三步，修改 Dockerfile 文件如下： FROMcentosRUN echo hello1RUN echo hello2 第四步，构建镜像： $ docker build . -t centos-hello2 ----------output---------- Step 1/3 : FROM centos ---\u003e 9f38484d220f Step 2/3 : RUN echo hello1 ---\u003e Using cache ---\u003e d5e9279556bb Step 3/3 : RUN echo hello2 ---\u003e Running in 10952b8314a7 hello2 Removing intermediate container 10952b8314a7 ---\u003e 129609739368 Successfully built 129609739368 Successfully tagged centos-hello2:latest 这一步构建镜像的时候使用了第二步构建的缓存镜像 d5e9279556bb（Using cache），构建镜像速度较快。 第五步，不使用缓存构建： $ docker build . -t cenots-hello2-noused-cache --no-cache=true ----------output---------- Sending build context to Docker daemon 3.072kB Step 1/3 : FROM centos ---\u003e 9f38484d220f Step 2/3 : RUN echo hello1 ---\u003e Running in c6c5e8d663d4 hello1 Removing intermediate container c6c5e8d663d4 ---\u003e 45f6aa55ff9f Step 3/3 : RUN echo hello2 ---\u003e Running in 83e31be999b8 hello2 Removing intermediate container 83e31be999b8 ---\u003e 86dd37807f27 Successfully built 86dd37807f27 Successfully tagged cenots-hello2-noused-cache:latest 这一步使用参数 –no-cache=true，构建镜像时不使用缓存，从而导致构建镜像的速度变慢。 第六步，修改 Dockerfile 文件如下： FROMcentosRUN echo hello0RUN echo hello1RUN echo hello2 第七步，构建镜像： $ docker build . -t centos-hello0-before-hello1 ----------output---------- Sending build context to Docker daemon 3.072kB Step 1/4 : FROM centos ---\u003e 9f38484d220f Step 2/4 : RUN echo hello0 ---\u003e Running in 584ea98c1a66 hello0 Removing intermediate container 584ea98c1a66 ---\u003e be2bf7b8e6c6 Step 3/4 : RUN echo hello1 ---\u003e Running in 26583e38906e hello1 Removing intermediate container 26583e38906e ---\u003e 57f389ce65dd Step 4/4 : RUN echo hello2 ---\u003e Running in 7a76cd08163b hello2 Removing intermediate container 7a76cd08163b ---\u003e e9d340a31150 Successfully built e9d340a31150 Successfully tagged centos-hello0-before-hello1:latest 由于 Dockerfile 在 echo hello1 之前插入了 echo hello0，故在构建镜像时，发现 centos 的所有子镜像被创建时使用的指令没有和当前指令一样的，从而导致缓存失效。 第八步，修改 Dockerfile 文件如下： FROMcentosRUN echo hello0RUN echo hello11RUN echo hello2 第九步，构建镜像： $ docker build . -t centos-hello11 ----------output---------- Step 1/4 : FROM centos ---\u003e 9f38484d220f Step 2/4 : RUN echo hello0 ---\u003e Using cache ---\u003e be2bf7b8e6c6 Step 3/4 : RUN echo hello11 ---\u003e Running in b401f45f6b69 hello11 Removing intermediate container b401f45f6b69 ---\u003e 60c181ac30e1 Step 4/4 : RUN echo hello2 ---\u003e Running in 79539b71f803 hello2 Removing intermediate container 79539b71f803 ---\u003e eb22881533b5 Successfully built eb22881533b5 Successfully tagged centos-hello-test:latest 可以看到 Step 2/4：RUN echo hello0 仍然使用了镜像 be2bf7b8e6c6，这时因为在第七步中，生成了子镜像 be2bf7b8e6c6。其实每执行完一条 Dockerfile 指令，都会生成一个中间层镜像。 具体查看这种中间层镜像的方式如下： $ docker images -a | grep be2bf7b8e6c6 ----------output---------- \u003cnone\u003e \u003cnone\u003e be2bf7b8e6c6 14 minutes ago 202MB 在大多数情况下，只需要简单地对比 Dockerfile 中的指令和子镜像。然而，有些指令需要更多的检查和解释。 对于 ADD 和 COPY 指令，镜像中对应文件的内容也会被检查，每个文件都会计算出一个校验和。文件的最后修改时间和最后访问时间不会纳入校验。在缓存的查找过程中， 会将这些校验和和已存在镜像中的文件校验和进行对比。如果文件有任何改变，比如内容和元数据，则缓存失效。 除了 ADD 和 COPY 指令，缓存匹配过程不会查看临时容器中的文件来决定缓存是否匹配。例如，当执行完 RUN apt-get -y update 指令后，容器中一些文件被更新，但 Docker 不会检查这些文件。这种情况下，只有指令字符串本身被用来匹配缓存。 一旦缓存失效，所有后续的 Dockerfile 指令都将产生新的镜像，缓存不会被使用。 综上，我们应该将经常变动的镜像层级放到 Dockerfile 文件的后面，这样才不会导致构建镜像时缓存经常失效，从而提高镜像构建速度。 ","date":"2022-03-24","objectID":"/docker-dockerfile-bp1/:8:0","tags":["Docker"],"title":"Dockerfile 最佳实践（常规指南和建议）","uri":"/docker-dockerfile-bp1/"},{"categories":["Docker"],"content":"9. 参考文献 [1] yeasy.Docker 从入门到实践[M]:367-368. [2] 廖煜,晏东.Docker 容器实战[M].北京:电子工业出版社,2016:181-183. ","date":"2022-03-24","objectID":"/docker-dockerfile-bp1/:9:0","tags":["Docker"],"title":"Dockerfile 最佳实践（常规指南和建议）","uri":"/docker-dockerfile-bp1/"},{"categories":["Design Pattern"],"content":"本文主要介绍了什么是单例模式，同时给出了其应用场景及 Golang 代码的具体实现。 ","date":"2022-03-12","objectID":"/design-pattern-singleton/:0:0","tags":["Design Pattern","Go"],"title":"设计模式系列（一）：单例模式","uri":"/design-pattern-singleton/"},{"categories":["Design Pattern"],"content":"1. 什么是单例 单例模式是一种常用的软件设计模式，其定义是单例对象的类只能允许一个实例存在。 ","date":"2022-03-12","objectID":"/design-pattern-singleton/:1:0","tags":["Design Pattern","Go"],"title":"设计模式系列（一）：单例模式","uri":"/design-pattern-singleton/"},{"categories":["Design Pattern"],"content":"1.1 优点 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。 避免对资源的多重占用（比如写文件操作）。 ","date":"2022-03-12","objectID":"/design-pattern-singleton/:1:1","tags":["Design Pattern","Go"],"title":"设计模式系列（一）：单例模式","uri":"/design-pattern-singleton/"},{"categories":["Design Pattern"],"content":"1.2 应用场景 外部资源：每台计算机有若干个打印机，但只能有一个PrinterSpooler，以避免两个打印作业同时输出到打印机。内部资源：大多数软件都有一个（或多个）属性文件存放系统配置，这样的系统应该有一个对象管理这些属性文件。 Windows 的Task Manager（任务管理器）就是很典型的单例模式（这个很熟悉吧），想想看，是不是呢，你能打开两个 windows task manager 吗？ windows 的 Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。 网站的计数器，一般也是采用单例模式实现，否则难以同步。 应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。 Web 应用的配置对象的读取，一般也应用单例模式，这个是由于配置文件是共享的资源。 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。数据库软件系统中使用数据库连接池，主要是节省打开或者关闭数据库连接所引起的效率损耗，这种效率上的损耗还是非常昂贵的，因为何用单例模式来维护，就可以大大降低这种损耗。 多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。 操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。 ","date":"2022-03-12","objectID":"/design-pattern-singleton/:1:2","tags":["Design Pattern","Go"],"title":"设计模式系列（一）：单例模式","uri":"/design-pattern-singleton/"},{"categories":["Design Pattern"],"content":"2. 具体实现 ","date":"2022-03-12","objectID":"/design-pattern-singleton/:2:0","tags":["Design Pattern","Go"],"title":"设计模式系列（一）：单例模式","uri":"/design-pattern-singleton/"},{"categories":["Design Pattern"],"content":"2.1 懒汉式，非线程安全 package main import ( \"fmt\" ) type restClient struct { protocol string hostname string } var client *restClient func GetClient() *restClient { if client == nil { client = \u0026restClient{ protocol: \"http\", hostname: \"www.baidu.com\", } } return client } func main() { a := GetClient() fmt.Printf(\"%p\\n\", a) b := GetClient() fmt.Printf(\"%p\\n\", b) } 运行结果如下。可以看到 a 和 b 的地址是相同的。 懒汉式非线程安全 a b 地址对比懒汉式非线程安全 a b 地址对比 \" 懒汉式非线程安全 a b 地址对比 但是这种方式存在一个缺点：非线程安全。两个线程同时来访问 instance == nil 逻辑，上面的结构体就会有多个对象了。 这边可以模拟下这种非线程安全的问题，代码如下： package main import ( \"fmt\" \"time\" ) type restClient struct { protocol string hostname string } var client *restClient func GetClient() *restClient { if client == nil { time.Sleep(1 * time.Second) client = \u0026restClient{ protocol: \"http\", hostname: \"www.baidu.com\", } } return client } func main() { go func() { a := GetClient() fmt.Printf(\"%p\\n\", a) }() go func() { b := GetClient() fmt.Printf(\"%p\\n\", b) }() time.Sleep(2 * time.Second) } 运行结果如下： 模拟非线程 a b 地址对比模拟非线程 a b 地址对比 \" 模拟非线程 a b 地址对比 ","date":"2022-03-12","objectID":"/design-pattern-singleton/:2:1","tags":["Design Pattern","Go"],"title":"设计模式系列（一）：单例模式","uri":"/design-pattern-singleton/"},{"categories":["Design Pattern"],"content":"2.2 饿汉式 package main import \"fmt\" type restClient struct { protocal string hostname string } var client *restClient = \u0026restClient{ protocal: \"http\", hostname: \"www.baidu.com\", } func GetClient() *restClient { return client } func main() { a := GetClient() fmt.Printf(\"%p\\n\", a) b := GetClient() fmt.Printf(\"%p\\n\", b) } 运行结果如下： 饿汉式 a b 地址对比饿汉式 a b 地址对比 \" 饿汉式 a b 地址对比 但饿汉式的单例实现也是有缺点的，如果单例创建初始化比较复杂耗时时，应用加载时间会延长。 ","date":"2022-03-12","objectID":"/design-pattern-singleton/:2:2","tags":["Design Pattern","Go"],"title":"设计模式系列（一）：单例模式","uri":"/design-pattern-singleton/"},{"categories":["Design Pattern"],"content":"2.3 懒汉加锁 package main import ( \"fmt\" \"sync\" \"time\" ) type restClient struct { protocal string hostname string } var client *restClient var mu sync.Mutex func GetClient() *restClient { mu.Lock() defer mu.Unlock() if client == nil { time.Sleep(1 * time.Second) client = \u0026restClient{ protocal: \"http\", hostname: \"www.baidu.com\", } } return client } func main() { go func() { a := GetClient() fmt.Printf(\"%p\\n\", a) }() go func() { b := GetClient() fmt.Printf(\"%p\\n\", b) }() time.Sleep(2 * time.Second) } 运行结果如下： 懒汉加锁 a b 地址对比懒汉加锁 a b 地址对比 \" 懒汉加锁 a b 地址对比 这种方式的懒汉加锁，虽然可以解决懒汉式的线程不安全问题。是它每次获取实例都需要通过加锁的方式，这种损耗也是极大的。 ","date":"2022-03-12","objectID":"/design-pattern-singleton/:2:3","tags":["Design Pattern","Go"],"title":"设计模式系列（一）：单例模式","uri":"/design-pattern-singleton/"},{"categories":["Design Pattern"],"content":"2.4 懒汉加锁，双重检查，带检查锁 package main import ( \"fmt\" \"sync\" \"time\" ) type restClient struct { protocal string hostname string } var client *restClient var mu sync.Mutex func GetClient() *restClient { if client == nil { time.Sleep(1 * time.Second) fmt.Println(\"execute lock\") mu.Lock() defer mu.Unlock() if client == nil { client = \u0026restClient{ protocal: \"http\", hostname: \"www.baidu.com\", } } } return client } func main() { go func() { a := GetClient() fmt.Printf(\"%p\\n\", a) }() go func() { b := GetClient() fmt.Printf(\"%p\\n\", b) }() time.Sleep(2 * time.Second) } 执行结果如下： 懒汉加锁双重检查 a b 地址对比懒汉加锁双重检查 a b 地址对比 \" 懒汉加锁双重检查 a b 地址对比 这种方式的懒汉加锁，避免了每次获取实例时都去加锁。但是如果两个线程同时进入 client == nil 的逻辑，还是不可避免的重复调用锁，不过已经从一定程度上避免了锁的重复调用了。 ","date":"2022-03-12","objectID":"/design-pattern-singleton/:2:4","tags":["Design Pattern","Go"],"title":"设计模式系列（一）：单例模式","uri":"/design-pattern-singleton/"},{"categories":["Design Pattern"],"content":"2.5 懒汉加锁，sync.Once 实现 package main import ( \"fmt\" \"sync\" \"time\" ) type restClient struct { protocal string hostname string } var client *restClient var once sync.Once func GetClient() *restClient { once.Do(func() { time.Sleep(1 * time.Second) client = \u0026restClient{} }) return client } func main() { go func() { a := GetClient() fmt.Printf(\"%p\\n\", a) }() go func() { b := GetClient() fmt.Printf(\"%p\\n\", b) }() time.Sleep(2 * time.Second) } 运行结果如下： 懒汉加锁 Sync.Once a b 地址对比懒汉加锁 Sync.Once a b 地址对比 \" 懒汉加锁 Sync.Once a b 地址对比 使用 sync.Once 实现单例更加简单。可以看到即使在 once.Do 使用了 time.Sleep 逻辑，最终 a 和 b 也是同一个示例。 而 sync.Once 内部本质上也是双重检查的方式，这种方式比自己写双重检查更简洁。Once 的源码如下： func (o *Once) Do(f func()) {　if atomic.LoadUint32(\u0026o.done) == 1 { return } o.m.Lock() defer o.m.Unlock() if o.done == 0 { defer atomic.StoreUint32(\u0026o.done, 1) f() } } ","date":"2022-03-12","objectID":"/design-pattern-singleton/:2:5","tags":["Design Pattern","Go"],"title":"设计模式系列（一）：单例模式","uri":"/design-pattern-singleton/"},{"categories":["Design Pattern"],"content":"3. 参考文献 [1] https://www.cnblogs.com/xuwendong/p/9633985.html. [2] https://www.runoob.com/design-pattern/singleton-pattern.html. [3] https://www.cnblogs.com/restartyang/articles/7770856.html. [4] https://studygolang.com/articles/11444. [5] https://studygolang.com/articles/11366. [6] https://www.cnblogs.com/wpnine/p/10426105.html. ","date":"2022-03-12","objectID":"/design-pattern-singleton/:3:0","tags":["Design Pattern","Go"],"title":"设计模式系列（一）：单例模式","uri":"/design-pattern-singleton/"},{"categories":["SCM"],"content":"本文主要记录了私有 cnpm 无法下载外网包的问题排查过程。同时给出对应的解决方案并对解决方案进行了验证。 ","date":"2022-03-02","objectID":"/scm-private-npm-error/:0:0","tags":["NPM","SCM"],"title":"私有 cnpm 无法下载外网包的问题排查","uri":"/scm-private-npm-error/"},{"categories":["SCM"],"content":"1. 故障现象 用户报障外网 npm 包下载不到。 下载报错下载报错 \" 下载报错 ","date":"2022-03-02","objectID":"/scm-private-npm-error/:1:0","tags":["NPM","SCM"],"title":"私有 cnpm 无法下载外网包的问题排查","uri":"/scm-private-npm-error/"},{"categories":["SCM"],"content":"2. 故障排查 首先确认官方是否存在 @babel/plugin-transform-destructuring@7.17.3 包。 $ npm config set registry https://registry.npm.taobao.org $ npm install @babel/plugin-transform-destructuring@7.17.3 如下图所示，发现官方确实存在该包。 官方源下载官方源下载 \" 官方源下载 再者，到公司 cnpm web 页面查找是否有 @babel/plugin-transform-destructuring@7.17.3 有包，查询发现没有该包。 查看日志 sync_error.log，发现如下报错： sync_error logsync_error log \" sync_error log postman 查看接口 https://registry.npm.taobao.org/-/all/since?stale=update_after\u0026startkey=164347154587 返回，发现返回结果 404。 postman 测试postman 测试 \" postman 测试 怀疑是官方 cnpm 否有改动，去 github 查看 issue。发现 issue 1704 和 issue 1719 和我们的情况类似。 根据 issue 描述情况，官方现在已经把 https://registry.npm.taobao.org/-/all/since?stale=update_after\u0026startkey=164347154587 接口下掉了，所以需要合并代码 1707 才能修复。 ","date":"2022-03-02","objectID":"/scm-private-npm-error/:2:0","tags":["NPM","SCM"],"title":"私有 cnpm 无法下载外网包的问题排查","uri":"/scm-private-npm-error/"},{"categories":["SCM"],"content":"3. 解决方案 将 config/index.js 中 https://registry.npm.taobao.org 替换为 https://registry.npmmirror.com。 由于，我们采用的是 2.19.4 tag 代码，将 1707 代码合并到 2.19.4 tag，进行验证。 验证过程中发现，总是报如下错误： SyncExpiredErrorSyncExpiredError \" SyncExpiredError 通过代码定位发现 sync/index.js 中 checkSyncStatus() 已经无法生效。因为官方不再以 lastSyncTime 来标记需要同步的包，而是换了 lastSeq 这个标记位。所以还需要注释掉两处 yield checkSyncStatus() 代码。 存量模块如何同步？通过 DB 查询库里面所有的非私有模块，编写一个脚本，循环调用如下接口即可： http://私有 registry 域名/@vue/babel-preset-app/sync method: put 其中 @vue/babel-preset-app 为模块名 ","date":"2022-03-02","objectID":"/scm-private-npm-error/:3:0","tags":["NPM","SCM"],"title":"私有 cnpm 无法下载外网包的问题排查","uri":"/scm-private-npm-error/"},{"categories":["SCM"],"content":"4. 方案验证 本地搭建服务，这边不再赘述，参照官网即可。 启动服务验证进行验证。 $ node /home/deploy/cnpmjs/dispatch.js 官网上传包进行验证。参照 https://blog.csdn.net/taoerchun/article/details/82531549 上传官方包。 查看同步日志，发现上传成功。但是有一个疑惑。为什么我只上传了一个包，下图显示的是两个包同步 success？ 上传成功日志上传成功日志 \" 上传成功日志 下载验证: $ npm install npm-xlxiao-test@latest --registry=http://127.0.0.1:7001 下载成功日志下载成功日志 \" 下载成功日志 验证成功。 ","date":"2022-03-02","objectID":"/scm-private-npm-error/:4:0","tags":["NPM","SCM"],"title":"私有 cnpm 无法下载外网包的问题排查","uri":"/scm-private-npm-error/"},{"categories":["SCM"],"content":"5. 源码剖析 由 4 中 “为什么我只上传了一个包，下图显示的是两个包同步 success？“的问题，便去查看了下源码。 定位到 sync/sync_exist.js 中 intersection 函数是这块的关键。 var packages = intersection(existPackages, updatesPackages); debug('Total %d packages to sync, top 10: %j', packages.length, packages.slice(0, 10)); if (!packages.length) { yield totalService.setLastExistSyncTime(lastSeq); debug('no packages need be sync, lastSeq: %s, changes: %s', lastSeq, changes.length); return { successes: [], fails: [] }; } function intersection(arrOne, arrTwo) { arrOne = arrOne || []; arrTwo = arrTwo || []; var map = {}; var results = []; arrOne.forEach(function (name) { map[name] = true; }); arrTwo.forEach(function (name) { map[name] === true \u0026\u0026 results.push(name); }); return results; } intersection 的主要作用就是如果一个包如果已经在库里面存在，并且在接口获取到的 updatesPackages 中，那么它就需要更新。 这次我只上传了 npm-xlxiao-test 一个包，但是日志显示更新了两次。所以怀疑官方接口返回了两个同样的包。调用接口 https://registry.npmmirror.com/_changes?since=27448638 验证猜测。发现确实会返回两个同样的包名，只是 changes 里面一个是 version，一个是 tag。 { \"results\": [ { \"seq\": 27448640, \"type\": \"PACKAGE_VERSION_ADDED\", \"id\": \"@ticketmaster/allure-create-app\", \"changes\": [ { \"version\": \"4.0.11-alpha.15\" } ] }, { \"seq\": 27448642, \"type\": \"PACKAGE_TAG_CHANGED\", \"id\": \"@ticketmaster/allure-create-app\", \"changes\": [ { \"tag\": \"latest\" } ] } ] } 那么日志显示同样的包同步两次成功，是否真的到官网去同步了两次呢？查看 sync/sync_exist.js 代码和 controllers/sync_module_worker.js 代码。 sync/sync_exist.js var worker = new SyncModuleWorker({ username: 'admin', name: packages, concurrency: config.syncConcurrency, syncUpstreamFirst: false, }); Status.init({need: packages.length}, worker); worker.start(); controllers/sync_module_worker.js SyncModuleWorker.prototype.start = function () { this.log('user: %s, sync %s worker start, %d concurrency, nodeps: %s, publish: %s', this.username, this.names[0], this.concurrency, this.noDep, this._publish); var that = this; co(function* () { // sync upstream if (that.syncUpstreamFirst) { try { yield that.syncUpstream(that.startName); } catch (err) { logger.error(err); } } if (that.type === 'user') { yield that.syncUser(); return; } var arr = []; for (var i = 0; i \u003c that.concurrency; i++) { arr.push(that.next(i)); } yield arr; }).catch(function (err) { logger.error(err); }); }; 关键逻辑还是在 that.next 里面。后面就没有再去追溯原因了。 ","date":"2022-03-02","objectID":"/scm-private-npm-error/:5:0","tags":["NPM","SCM"],"title":"私有 cnpm 无法下载外网包的问题排查","uri":"/scm-private-npm-error/"},{"categories":["SCM"],"content":"6. 一些疑惑 修复过程中第一次设置 total 表 last_exist_sync_time 字段的值，取自 https://registry.npmmirror.com/ 接口 update_seq 的值。后续这个值被当做参数 lastSeq 传递给官方源，来获取需要变更的包。代码如下所示： 上传成功日志上传成功日志 \" 上传成功日志 那么官方 lastSeq 的值的意义是什么？我怎么才能设置一个值获取到我之前变化的包呢？ ","date":"2022-03-02","objectID":"/scm-private-npm-error/:6:0","tags":["NPM","SCM"],"title":"私有 cnpm 无法下载外网包的问题排查","uri":"/scm-private-npm-error/"},{"categories":["Kubernetes"],"content":"本文主要是看了极客时间上《Kubernetes 架构原则和对象设计》的分享而做的一些笔记及总结。 ","date":"2022-02-19","objectID":"/gk-cloudnative-k8s-arch/:0:0","tags":["Kubernetes","Geek"],"title":"[笔记]Kubernetes 架构原则和对象设计","uri":"/gk-cloudnative-k8s-arch/"},{"categories":["Kubernetes"],"content":"1. Kubernetes 源码如何走读 cmd 里面的代码调用 pkg 代码，cmd 里面执行 go build 会生成各个组件的二进制文件，它是编译的入口。所以读代码大部分读 pkg 里面的代码。 下图主要 Kubernetes 代码分布结构： Kubernetes 代码分布结构Kubernetes 代码分布结构 \" Kubernetes 代码分布结构 OpenAPI 是 api 定义的标准规范。Kubernetes 主要遵循 Schema Object 规范定义对象。 ","date":"2022-02-19","objectID":"/gk-cloudnative-k8s-arch/:1:0","tags":["Kubernetes","Geek"],"title":"[笔记]Kubernetes 架构原则和对象设计","uri":"/gk-cloudnative-k8s-arch/"},{"categories":["Kubernetes"],"content":"2. 命令式和声明式 命令式： 此方法明确写出系统应该执行某指令，并且期待系统返回期望结果。 我要你做什么，怎么做，请严格按照我说的做。 比如遥控器你输入频道 1，电视机跳转到频道 1。 声明式： 声明式系统指程序代码描述系统应该做什么而不是怎么做。仅限于描述要达到什么目的，如何达到目的交给系统。 我需要你帮我做点事，但是我只告诉你我需要你做什么，不是你应该怎么做。 比如调节空调温度，你输入期望的温度，但是温度不会立刻到达相应的温度。 Kubernetes 就是声明式的系统，它具有幂等性。每次我要你做事，请给我返回相同结果。 ","date":"2022-02-19","objectID":"/gk-cloudnative-k8s-arch/:2:0","tags":["Kubernetes","Geek"],"title":"[笔记]Kubernetes 架构原则和对象设计","uri":"/gk-cloudnative-k8s-arch/"},{"categories":["Kubernetes"],"content":"3. Kubernetes：声明式系统 核心对象如下： Node：计算节点的抽象，用来描述计算节点的资源抽象、健康状态等。 Namespace：资源隔离的基本单位，可以简单理解为文件系统中的目录结构。 Kubernetes 有 Namespace 和 Non-Namesapce 对象。Node 就属于 Non-Namesapce 对象，它属于整个集群。 Pod：用来描述应用实例，包括镜像地址、资源需求等。Kubernetes 中最核心的对象，也是打通应用和基础架构的秘密武器。 Service：服务如何将应用发布成服务，本质上是负载均衡和域名服务的声明。 ","date":"2022-02-19","objectID":"/gk-cloudnative-k8s-arch/:3:0","tags":["Kubernetes","Geek"],"title":"[笔记]Kubernetes 架构原则和对象设计","uri":"/gk-cloudnative-k8s-arch/"},{"categories":["Kubernetes"],"content":"4. Kubernetes 架构 基本架构图： Kubernetes 基本架构图Kubernetes 基本架构图 \" Kubernetes 基本架构图 Node 节点： kubelet 组件：每个节点上跑一个 kubelet，负责把节点状态的上报给 api server。 负责调度到对应节点的 Pod 的生命周期管理，执行任务并将 Pod 状态上报给主节点。通过容器运行时（拉取镜像、启动和停止容器等）来运行这些容器，还会定期执行被请求的容器的健康探测程序。 kube-proxy 组件：负责节点的网络，在主机上维护网络规则并执行连接转发。还负责对正在服务的 Pod 进行负载平衡。 service 的负载均衡都是有由 proxy 来配置的。 Master 节点： api server 组件：这是 Kubernetes 控制面板中唯一带有用户可访问 API 以及用户可交互的组件。API 服务器会暴露一个 RESTful 的 Kubernetes API 并使用 JSON 格式的清单文件(manifest files)。 api server 部署在 k8s master 上，属于管理节点上的一个组件，也是整个集群的 api 网关，组件和组件之间不通信，所有的组件都是通过 api server 通信。 etcd 组件：Kubernetes 使用 “etcd”。这是一个强大的、稳定的、高可用的键值存储，被 Kubernetes 用于长久储存所有的 API 对象。 scheduler 组件：调度器会监控新建的 pods（一组或一个容器）并将其分配给节点。 用户建一个 pod，scheduler 调度到对应的节点。kubelet 会把每个节点的可用状况，资源状态上报给 api server，存储到 etcd 里面去。当用户建 pod 时，请求会被发到 api server，scheduler 会找当前工作节点最适合当前的作业，它就把 pod 的 node name 更新掉，写回 api server，api server 保存到 etcd。api server 保存这个数据之后，某个工作节点的 kubelet 发现保存到它这边了，这个时候回去启动相应的 pod。kubelet 去读取当前镜像是什么，需要的资源是什么，然后调用容器接口，运行时会去下载容器镜像，启动容器实例，起的时候放到对应的 namespace 里面，通过 cgroup 控制资源，帮它挂载网路。 controller 组件：被称为“kube-controller manager”，它运行着所有处理集群日常任务的控制器。包括了节点控制器、副本控制器、端点(endpoint)控制器以及服务账户等。 controller 会一直监控当前集群状态，监控它感兴趣的对象，如果对象发生变化，controller 就会做出相应的操作。比如某个节点或者应用发生了状态变化，那么需要自动化程序去做些事情。比如某个节点跑了一个 pod，这个时候节点磁盘坏了，或者系统死机等等，这个时候该节点上的应用就没法提供服务了。controller 里面有很多控制器，不同的控制器，node controller 发现某个节点坏了，这里面运行的所有 pod 都不能正常提供服务，它就应该把这里面的 pod 杀掉。如果是通过 deployment 创建的节点，其他控制器就会创建新的 pod，并且调度到其他节点上。控制器会一直监控当前集群状态，监控它感兴趣的对象，如果对象发生变化，控制器就会做出相应的操作。 扩展架构图： Kubernetes 扩展架构图Kubernetes 扩展架构图 \" Kubernetes 扩展架构图 ","date":"2022-02-19","objectID":"/gk-cloudnative-k8s-arch/:4:0","tags":["Kubernetes","Geek"],"title":"[笔记]Kubernetes 架构原则和对象设计","uri":"/gk-cloudnative-k8s-arch/"},{"categories":["Kubernetes"],"content":"5. etcd etcd 是 CoreOS 基于 Raft 开发的分布式 key-value 存储，可用于服务发现、共享配置以及一致性保障(如数据库选主、分布式锁等)。 基本的 key-value 存储 监听机制（客户端访问 etcd 数据时，不是通过 get 方式，而是通过 watch 方式。客户端通过长连接监听方式，减少数据库的压力） key 的过期及续约机制，用于监控和服务发现 原子 CAS 和 CAD，用于分布式锁和 leader 选举 etcd 集群etcd 集群 \" etcd 集群 如何查看 etcd 数据？ 查看以 / 开头的 key: etcdctl --endpoints https://localhost:2379 --cert /etc/kubernetes/pki/etcd/server.crt --key /etc/kubernetes/pki/etcd/server.key --cacert /etc/kubernetes/pki/etcd/ca.crt get --keys-only --prefix / 监听 default namespace 下 pod centos-5fddd22dd-nftnk 的变化： etcdctl --endpoints https://localhost:2379 --cert /etc/kubernetes/pki/etcd/server.crt --key /etc/kubernetes/pki/etcd/server.key --cacert /etc/kubernetes/pki/etcd/ca.crt watch --prefix /registry/pods/default/centos-5fddd22dd-nftnk api server 是唯一一个和 etcd 通信的组件，它启动的时候会构建一个 watch cache，对 etcd 里面所有的数据做监听，然后把 etcd 数据放到 api server 进行缓存。api server 也提供了 watch 机制，所有的 kubernetes 组件，连接到 api server，先通过 list 把当前状态查询出来，通过 watch 的机制和 api server 保持长链接，如果 api server 里面的内容发生变更，会通过 event 的机制通知到每个组件，每个组件再执行自己的业务逻辑。 ","date":"2022-02-19","objectID":"/gk-cloudnative-k8s-arch/:5:0","tags":["Kubernetes","Geek"],"title":"[笔记]Kubernetes 架构原则和对象设计","uri":"/gk-cloudnative-k8s-arch/"},{"categories":["Kubernetes"],"content":"6. APIServer Kube-APIServer 是 Kubernetes 最重要的核心组件之一，主要提供以下功能: 提供集群管理的 REST API 接口，包括： 认证 Authentication 授权 Authorization 准入 Admission（Mutating \u0026 Valiating） 提供其他模块之间的数据交互和通信的枢纽（其他模块通过 APIServer 查询或修改数据，只有 APIServer 才直接操作 etcd）。 APIServer 提供 etcd 数据缓存以减少集群对 etcd 的访问。 APIServer 和 etcd 互通APIServer 和 etcd 互通 \" APIServer 和 etcd 互通 APIServer 展开图APIServer 展开图 \" APIServer 展开图 ","date":"2022-02-19","objectID":"/gk-cloudnative-k8s-arch/:6:0","tags":["Kubernetes","Geek"],"title":"[笔记]Kubernetes 架构原则和对象设计","uri":"/gk-cloudnative-k8s-arch/"},{"categories":["Kubernetes"],"content":"7. Controller Manager 主要功能： Controller Manager 是集群的大脑，是确保整个集群动起来的关键。 作用是确保 Kubernetes 遵循声明式系统规范，确保系统的真实状态(Actual State)与用户定义的期望状态（Desired State）一致。 Controller Manager 是多个控制器的组合，每个 Controller 事实上都是一个 control loop，负责侦听其管控的对象，当对象发生变更时完成配置。 Controller 配置失败通常会触发自动重试，整个集群会在控制器不断重试的机 制下确保最终一致性( Eventual Consistency)。 控制器里面的逻辑基本都是一样的，一边监听 api server 的变化，api server 那边发生变化，会通知控制器。控制器里面的生产者会把这些变化放到一个队列里面，控制器的消费者再从队列里面取数据，取出来之后再做相应的逻辑处理。 任何的控制器都是生产者消费者模型。 写 contorller 时，如果消费失败了，应该把他们重新塞回队列里面，留给后面继续重试。出错重试的时候要有按指数级 rate limit，防止把 api server 打挂掉。 控制器的工作流程： 控制器的工作流程控制器的工作流程 \" 控制器的工作流程 上面是一个生产者消费者模型。这里面部分代码可以由 kubernetes 代码框架，比如 kubebuilder 生成。主要生成 informer（event 观察的代码框架）和 lister（获取全量数据的代码框架）两部分内容。 informer 和 lister 会去观察和监听的某一个对象，监听的对象会有 event，比如 Add Event、Delete Event 等。不同的 event 可以注册不同的 handler。发生这些 Event，会先塞入队列，把这些对象的 key 取出来，把这些 key（就是 namepsace 和 name）放到 Ratelimit Q 里面。另外一边会启动 goroutine，可以配置一个或多个 worker，从队列里面取数据，完成这些对象变化的处理，直到队列空位置。如果出错，重新塞回队列里面。 Informer 的内部机制： Informer 的内部机制Informer 的内部机制 \" Informer 的内部机制 这个要对应 kubernetes 代码去读。其目的就是构建一个快速处理对象变化的框架。 代码参考链接：informer-framework。 控制器的协同工作原理： 控制器的协同工作原理控制器的协同工作原理 \" 控制器的协同工作原理 ","date":"2022-02-19","objectID":"/gk-cloudnative-k8s-arch/:7:0","tags":["Kubernetes","Geek"],"title":"[笔记]Kubernetes 架构原则和对象设计","uri":"/gk-cloudnative-k8s-arch/"},{"categories":["Kubernetes"],"content":"8. 参考文献 [1] https://u.geekbang.org/lesson/167?article=426905. ","date":"2022-02-19","objectID":"/gk-cloudnative-k8s-arch/:8:0","tags":["Kubernetes","Geek"],"title":"[笔记]Kubernetes 架构原则和对象设计","uri":"/gk-cloudnative-k8s-arch/"},{"categories":["Golang"],"content":"本文主要介绍了 golang 语言中的空结构体及其使用场景。 ","date":"2022-02-15","objectID":"/go-empty-struct.go/:0:0","tags":["Golang"],"title":"Golang 空结构体妙用","uri":"/go-empty-struct.go/"},{"categories":["Golang"],"content":"1. 空结构体 空结构体的宽度是 0，占用了 0 字节的内存空间。 由于空结构体占用0字节，那么空结构体也不需要填充字节。所以空结构体组成的组合数据类型也不会占用内存空间。 示例： ```go package main import ( \"fmt\" \"unsafe\" ) type S struct { A struct{} B struct{} } func main() { var s struct{} fmt.Println(unsafe.Sizeof(s)) var s1 S fmt.Println(unsafe.Sizeof(s1)) } ``` ","date":"2022-02-15","objectID":"/go-empty-struct.go/:1:0","tags":["Golang"],"title":"Golang 空结构体妙用","uri":"/go-empty-struct.go/"},{"categories":["Golang"],"content":"2. chan struct 首先看下 go by example Ticker 代码示例： package main import ( \"fmt\" \"time\" ) func main() { ticker := time.NewTicker(500 * time.Millisecond) done := make(chan bool) go func() { for { select { case \u003c-done: return case t := \u003c-ticker.C: fmt.Println(\"Tick at\", t) } } }() time.Sleep(1600 * time.Millisecond) ticker.Stop() done \u003c- true fmt.Println(\"Ticker stopped\") } 这里使用了 done := make(chan bool)，这并不是最优解，因为 bool 类型还是有大小的。这里可以使用 make(chan struct{}) 来控制定时器任务的结束。 使用空结构体 channel := make(chan struct{}) 好处： 省内存，尤其在事件通信的时候。 struct 零值就是本身，读取 close 的 channel 返回零值。 优化后代码： package main import ( \"fmt\" \"time\" ) func main() { ticker := time.NewTicker(500 * time.Millisecond) done := make(chan struct{}) go func() { for { select { case \u003c-done: return case t := \u003c-ticker.C: fmt.Println(\"Tick at\", t) } } }() time.Sleep(1600 * time.Millisecond) ticker.Stop() done \u003c- struct{}{} fmt.Println(\"Ticker stopped\") } ","date":"2022-02-15","objectID":"/go-empty-struct.go/:2:0","tags":["Golang"],"title":"Golang 空结构体妙用","uri":"/go-empty-struct.go/"},{"categories":["Golang"],"content":"3. 参考文献 [1] https://blog.csdn.net/inthat/article/details/106917358. [2] https://gobyexample-cn.github.io/tickers ","date":"2022-02-15","objectID":"/go-empty-struct.go/:3:0","tags":["Golang"],"title":"Golang 空结构体妙用","uri":"/go-empty-struct.go/"},{"categories":["Jenkins"],"content":"1. 实验环境 本次实验采用的机器为 MAC。 需要预装的软件：Docker。 ","date":"2020-06-24","objectID":"/jenkins-enlightenment/:1:0","tags":["Jenkins"],"title":"一文带你玩转 Jenkins","uri":"/jenkins-enlightenment/"},{"categories":["Jenkins"],"content":"2. 构建 Jenkins Master 镜像 首先请先下载我的个人项目 jenkins-alpine-dockerfiles。该项目是从 Jenkins 官方项目剥离出的简化版 Dockerfile。基于该项目可以构建出 jenkins-master、jenkins-slave 镜像。 下载完成后，开始构建镜像。 构建命令如下： docker build \\ --build-arg HTTPS_PROXY=your-proxy \\ --build-arg HTTP_PROXY=your-proxy \\ -t jenkins-master:2.345 -f master/Dockerfile ./master 构建说明： 构建时需要添加自己的 PROXY，如果不添加 PROXY，由于需要访问一些国外的站点，很有可能导致构建失败。如果不需要配置 PROXY，去除命令中的 PROXY 即可。 为什么镜像的 tag 是 2.345？因为写这篇博客时，官方最新的版本为 2.345，而我的个人项目 jenkins-alpine-dockerfiles 用的也是这个版本。 构建结果如下： jenkins 镜像构建jenkins 镜像构建 \" jenkins 镜像构建 ","date":"2020-06-24","objectID":"/jenkins-enlightenment/:2:0","tags":["Jenkins"],"title":"一文带你玩转 Jenkins","uri":"/jenkins-enlightenment/"},{"categories":["Jenkins"],"content":"3. 启动 Jenkins Master 预处理： mkdir -p /tmp/jenkins_home # 和容器保持一致 sudo chown -R 1000:1000 /tmp/jenkins_home # 修改权限，否则会报如下报错 sudo chmod 777 /tmp/jenkins_home jenkins 容器启动报错jenkins 容器启动报错 \" jenkins 容器启动报错 启动命令如下： docker run --name jenkins-master \\ -p 8080:8080 -v /tmp/jenkins_home:/var/jenkins_home -d jenkins-master:2.345 启动说明： -v /tmp/jenkins_home:/var/jenkins_home 表示将宿主机目录 /tmp/jenkins_home 挂载到容器目录 /var/jenkins_home 下。 启动结果： jenkins 容器启动jenkins 容器启动 \" jenkins 容器启动 访问地址：http://127.0.0.1:8080/ 访问 Jenkins访问 Jenkins \" 访问 Jenkins 进入容器，查看 /var/jenkins_home/secrets/initialAdminPassword 内容（或直接查看宿主机 /tmp/jenkins_home/secrets/initialAdminPassword 内容），并填入上图中。 安装插件，初始建议不安装任何插件，直接点击下图 X 即可。一旦选择 Install suggested plugins，Jenkins 会默认装上一堆插件，这会导致你不清楚安装的每一个插件的具体功能。可以后期用到一个插件，便去研究一个插件的特性，从而打到庖丁解牛的目的。 Jenkins 插件安装Jenkins 插件安装 \" Jenkins 插件安装 点击 Start using Jenkins。 Jenkins is readyJenkins is ready \" Jenkins is ready 至此，Jenkins Master 启动完毕。 为了方便后面的登录，可以新创建一个管理员账户和密码。 Manage UsersManage Users \" Manage Users Create UserCreate Users \" Create User ","date":"2020-06-24","objectID":"/jenkins-enlightenment/:3:0","tags":["Jenkins"],"title":"一文带你玩转 Jenkins","uri":"/jenkins-enlightenment/"},{"categories":["Jenkins"],"content":"4. 创建 Job 并完成构建 ","date":"2020-06-24","objectID":"/jenkins-enlightenment/:4:0","tags":["Jenkins"],"title":"一文带你玩转 Jenkins","uri":"/jenkins-enlightenment/"},{"categories":["Jenkins"],"content":"4.1 创建 Job 创建 Job 步骤 1创建 Job 步骤 1 \" 创建 Job 步骤 1 创建 Job 步骤 2创建 Job 步骤 2 \" 创建 Job 步骤 2 ","date":"2020-06-24","objectID":"/jenkins-enlightenment/:4:1","tags":["Jenkins"],"title":"一文带你玩转 Jenkins","uri":"/jenkins-enlightenment/"},{"categories":["Jenkins"],"content":"4.2 配置 Job General 配置： General 配置General 配置 \" General 配置 Build 配置： Build 配置Build 配置 \" Build 配置 ","date":"2020-06-24","objectID":"/jenkins-enlightenment/:4:2","tags":["Jenkins"],"title":"一文带你玩转 Jenkins","uri":"/jenkins-enlightenment/"},{"categories":["Jenkins"],"content":"4.3 构建 构建： 构建构建 \" 构建 查看构建日志： 查看构建日志查看构建日志 \" 查看构建日志 ","date":"2020-06-24","objectID":"/jenkins-enlightenment/:4:3","tags":["Jenkins"],"title":"一文带你玩转 Jenkins","uri":"/jenkins-enlightenment/"},{"categories":["Jenkins"],"content":"5. 升级 Jenkins Master 访问 https://updates.jenkins-ci.org/download/war/ 地址，找到最新版本 Jenkins 的 SHA-256 值。替换 jenkins-alpine-dockerfiles 项目 master 目录下 Dockerfile 文件的 Jenkins 版本号和 JENKINS_SHA 的值。 Upgrade Jenkins MasterUpgrade Jenkins Master \" Upgrade Jenkins Master 参照第 2 小节，重新构建镜像，基于该镜像启动新的 Jenkins 容器，这样 Jenkins 就升级完成了（这边不考虑插件的升级）。 ","date":"2020-06-24","objectID":"/jenkins-enlightenment/:5:0","tags":["Jenkins"],"title":"一文带你玩转 Jenkins","uri":"/jenkins-enlightenment/"},{"categories":["Jenkins"],"content":"6. 常用插件安装及升级 常用插件安装请参照文章：https://www.lesliexlxiao.com/jenkins-common-plugins/ 如何加速插件安装，将插件源替换成 https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json 即可。 更新 Jenkins 插件源步骤 1更新 Jenkins 插件源步骤 1 \" 更新 Jenkins 插件源步骤 1 更新 Jenkins 插件源步骤 2更新 Jenkins 插件源步骤 2 \" 更新 Jenkins 插件源步骤 2 注意：更新完插件源之后，重启下 Jenkins。 ","date":"2020-06-24","objectID":"/jenkins-enlightenment/:6:0","tags":["Jenkins"],"title":"一文带你玩转 Jenkins","uri":"/jenkins-enlightenment/"},{"categories":["Jenkins"],"content":"本文主要介绍了 Windows 环境下如何添加 jenkins-slave 节点，以及安装过程中一些常见问题如何解决。 ","date":"2019-05-30","objectID":"/jenkins-install-windows-slave/:0:0","tags":["Jenkins"],"title":"Windows 环境下如何添加 jenkins-slave 节点","uri":"/jenkins-install-windows-slave/"},{"categories":["Jenkins"],"content":"1. 实验环境 本次实验采用服务器为 Windows Server 2012。 实验中安装软件的版本均为本次实验采用的版本。 ","date":"2019-05-30","objectID":"/jenkins-install-windows-slave/:1:0","tags":["Jenkins"],"title":"Windows 环境下如何添加 jenkins-slave 节点","uri":"/jenkins-install-windows-slave/"},{"categories":["Jenkins"],"content":"2. 预装软件 ","date":"2019-05-30","objectID":"/jenkins-install-windows-slave/:2:0","tags":["Jenkins"],"title":"Windows 环境下如何添加 jenkins-slave 节点","uri":"/jenkins-install-windows-slave/"},{"categories":["Jenkins"],"content":"2.1 JDK 安装 作用：jenkins-slave 服务启动依赖于 JDK。 下载：下载地址。 安装：按照下图连续点击下一步即可。 JDK 安装JDK 安装 \" JDK 安装 验证：打开 Windows PowerShell，输入如下命令进行验证： C:\\Users\\xlxiao\u003e java -version ----------output---------- java version \"1.8.0_181\" Java(TM) SE Runtime Environment (build 1.8.0_181-b13) Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode) ","date":"2019-05-30","objectID":"/jenkins-install-windows-slave/:2:1","tags":["Jenkins"],"title":"Windows 环境下如何添加 jenkins-slave 节点","uri":"/jenkins-install-windows-slave/"},{"categories":["Jenkins"],"content":"2.2 Ruby 安装 安装版本：ruby2.3.3。 作用：如果执行 jenkins 任务使用的脚本语言是 Ruby 编写，则需要安装 Ruby。 下载：下载地址。 安装：按照下图连续点击下一步即可。 Ruby 安装Ruby 安装 \" Ruby 安装 验证：打开 Windows PowerShell，输入如下命令进行验证： C:\\Users\\xlxiao\u003e ruby -v ----------output---------- ruby 2.3.3p222 (2016-11-21 revision 56859) [x64-mingw32] ","date":"2019-05-30","objectID":"/jenkins-install-windows-slave/:2:2","tags":["Jenkins"],"title":"Windows 环境下如何添加 jenkins-slave 节点","uri":"/jenkins-install-windows-slave/"},{"categories":["Jenkins"],"content":"2.3 Git 安装 作用：构建任务的脚本语言中如果使用 Git 下载代码，则需要安装 Git。 下载地址：https://git-scm.com/download/win。 安装：按照下图连续点击下一步即可。 Git 安装Git 安装 \" Git 安装 验证：打开 Windows PowerShell，输入如下命令进行验证： C:\\Users\\xlxiao\u003e git version ----------output---------- git version 2.21.0.windows.1 ","date":"2019-05-30","objectID":"/jenkins-install-windows-slave/:2:3","tags":["Jenkins"],"title":"Windows 环境下如何添加 jenkins-slave 节点","uri":"/jenkins-install-windows-slave/"},{"categories":["Jenkins"],"content":"3. 添加 slave 节点 ","date":"2019-05-30","objectID":"/jenkins-install-windows-slave/:3:0","tags":["Jenkins"],"title":"Windows 环境下如何添加 jenkins-slave 节点","uri":"/jenkins-install-windows-slave/"},{"categories":["Jenkins"],"content":"3.1 主节点添加 slave 节点 主节点添加 slave 节点步骤 1主节点添加 slave 节点步骤 1 \" 主节点添加 slave 节点步骤 1 主节点添加 slave 节点步骤 2主节点添加 slave 节点步骤 2 \" 主节点添加 slave 节点步骤 2 ","date":"2019-05-30","objectID":"/jenkins-install-windows-slave/:3:1","tags":["Jenkins"],"title":"Windows 环境下如何添加 jenkins-slave 节点","uri":"/jenkins-install-windows-slave/"},{"categories":["Jenkins"],"content":"3.2 安装 jenkins-slave 服务 进入页面 http://192.168.2.1:8080/，点击如下刚刚配置的未在线 windows-192-168-2-2。 未在线 windows-192-168-2-2未在线 windows-192-168-2-2 \" 未在线 windows-192-168-2-2 进入 http://192.168.2.1:8080/computer/windows-192-168-2-2/，点击 Launch 进行安装。 安装 slave安装 slave \" 安装 slave 安装为 windows service。 安装为 windows service安装为 windows service \" 安装为 windows service 查看 jenkins-slave 服务，打开任务管理器，查看服务。 任务管理器 jenkins-slave 服务任务管理器 jenkins-slave 服务 \" 任务管理器 jenkins-slave 服务 ","date":"2019-05-30","objectID":"/jenkins-install-windows-slave/:3:2","tags":["Jenkins"],"title":"Windows 环境下如何添加 jenkins-slave 节点","uri":"/jenkins-install-windows-slave/"},{"categories":["Jenkins"],"content":"4. 常见问题 ","date":"2019-05-30","objectID":"/jenkins-install-windows-slave/:4:0","tags":["Jenkins"],"title":"Windows 环境下如何添加 jenkins-slave 节点","uri":"/jenkins-install-windows-slave/"},{"categories":["Jenkins"],"content":"4.1 Cannot run program “nohup” 报错信息：java.io.IOException: Cannot run program “nohup”。 Cannot run program nohupCannot run program \u0026ldquo;nohup\u0026rdquo; \" Cannot run program nohup 报错原因：因为系统没法找到 nohup 执行程序。 解决方案： 将 C:\\Program Files\\Git\\usr\\bin 添加到 PATH 环境变量，这样系统即找打 nohup 执行程序了。从下图可以看到 nohup 程序确实存在于 C:\\Program Files\\Git\\usr\\bin 路径下： nohup 执行程序路径nohup 执行程序路径 \" nohup 执行程序路径 重启 jekins-slave 服务，如下图所示： 重启 Jenkins 服务重启 Jenkins 服务 \" 重启 Jenkins 服务 参考：https://stackoverflow.com/questions/45140614/jenkins-pipeline-sh-fail-with-cannot-run-program-nohup-on-windows/45151156。 ","date":"2019-05-30","objectID":"/jenkins-install-windows-slave/:4:1","tags":["Jenkins"],"title":"Windows 环境下如何添加 jenkins-slave 节点","uri":"/jenkins-install-windows-slave/"},{"categories":["Jenkins"],"content":"4.2 Could not read from remote repository 报错信息：Could not read from remote repository。访问 Gitlab 没有权限。 Could not read from remote repositoryCould not read from remote repository \" Could not read from remote repository 报错原因：从下图可以看出 jenkins-slave 服务是以 SYSTEM 用户去启动的，而我们的 ssh-key 并没有种到 SYSTEM 用户下，所以没法下载 git 代码。 Jenkins 启动用户Jenkins 启动用户 \" Jenkins 启动用户 解决方案 1： 在当前用户生成 ssh-key，并在当前用户下第一次通过 git clone 命令去访问想要访问的仓库，这时会在 .ssh 目录生成 knows_hosts 文件。 将生成的 .ssh 目录复制到 C:\\Windows\\System32\\config\\systemprofile\\ 下。 C:\\Windows\\System32\\config\\systemprofile\\\\.sshC:\\Windows\\System32\\config\\systemprofile\\.ssh \" C:\\Windows\\System32\\config\\systemprofile\\\\.ssh 注意：knows_hosts 文件同样要 copy 到该目录，否则无法访问仓库。 重启 jenkins-slave 服务。 解决方案 2： 在当前用户生成 ssh-key，并在当前用户下第一次通过 git clone 命令去访问想要访问的仓库。 根据下面的步骤，改变服务登录用户，重启 jenkins-slave 服务。这样 jenkins-slave 就是以当前用户启动的了。 Jenkins 服务Jenkins 服务 \" Jenkins 服务 Jenkins 服务属性Jenkins 服务属性 \" Jenkins 服务属性 更改 Jenkins 服务属性更改 Jenkins 服务属性 \" 更改 Jenkins 服务属性 ","date":"2019-05-30","objectID":"/jenkins-install-windows-slave/:4:2","tags":["Jenkins"],"title":"Windows 环境下如何添加 jenkins-slave 节点","uri":"/jenkins-install-windows-slave/"},{"categories":["Jenkins"],"content":"4.3 bundler/setup LoadError 报错信息：cannot load such file – bundler/setup (LoadError) cannot load such filecannot load such file \" cannot load such file 报错原因：没有安装 bundler 解决方案：安装 bundler C:\\Users\\xlxiao\u003e gem source -r https://rubygems.org/ C:\\Users\\xlxiao\u003e gem source -a 自己公司内部源 C:\\Users\\xlxiao\u003e gem install bundler ","date":"2019-05-30","objectID":"/jenkins-install-windows-slave/:4:3","tags":["Jenkins"],"title":"Windows 环境下如何添加 jenkins-slave 节点","uri":"/jenkins-install-windows-slave/"},{"categories":["Jenkins"],"content":"4.4 构建日志乱码 构建日志乱码构建日志乱码 \" 构建日志乱码 报错原因：编码设置不正确 解决办法：添加系统环境变量 JAVA_TOOL_OPTIONS，值设置为 -Dfile.encoding=UTF-8 设置系统环境变量 JAVA_TOOL_OPTIONS设置系统环境变量 JAVA_TOOL_OPTIONS \" 设置系统环境变量 JAVA_TOOL_OPTIONS 注意：设置完系统环境变量之后，必须要重新启动机器才能生效。 ","date":"2019-05-30","objectID":"/jenkins-install-windows-slave/:4:4","tags":["Jenkins"],"title":"Windows 环境下如何添加 jenkins-slave 节点","uri":"/jenkins-install-windows-slave/"},{"categories":["Jenkins"],"content":"4.5 将 jenkins-slave 服务安装成 Windows Service 报错 虽然在 Windows 环境中看上去是安装成功了，但是在服务端查看日志，报错如下： slave 连接 master 报错slave 连接 master 报错 \" slave 连接 master 报错 报错原因：原来 jenkins-slave 作为 Windows Service 安装过，会有残留文件存在，导致报错。 解决办法： 第一步：停止 Jenkins 服务。 停止 Jenkins 服务停止 Jenkins 服务 \" 停止 Jenkins 服务 第二步：删除 Jenkins 服务。以管理员身份打开 cmd 窗口，执行命令 “sc delete jenkinsslave-d__jenkins”（注意：命令中的是双下划线）。 管理员方式打开 cmd管理员方式打开 cmd \" 管理员方式打开 cmd 第三步：删除历史的 jenkins-slave 数据。 历史的 jenkins-slave 数据历史的 jenkins-slave 数据 \" 历史的 jenkins-slave 数据 第四步：将 jenkins-slave 服务安装成 Windows Service。 ","date":"2019-05-30","objectID":"/jenkins-install-windows-slave/:4:5","tags":["Jenkins"],"title":"Windows 环境下如何添加 jenkins-slave 节点","uri":"/jenkins-install-windows-slave/"},{"categories":["Management"],"content":"本文主要是对极客时间《技术管理实战 36 讲》管理沟通篇做的笔记，详细内容可参考：任务执行篇。 ","date":"2022-05-13","objectID":"/gk-tmp-management-communication/:0:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：管理沟通篇","uri":"/gk-tmp-management-communication/"},{"categories":["Management"],"content":"管理沟通那些事儿 四项工作有什么特点： 技术开发工作：使用电脑、学习语言、设计算法、开发功能、遵循规范…… 项目管理工作：明确需求、制定计划、把控流程、推动执行、通报进展…… 和下级合作：分配任务、跟进进展、辅导帮助、激发动力、评价结果…… 和上级合作：领取任务、领会意图、提供建议、申请资源、寻求指导…… 第一，技术开发工作，主要和客观事物、自然规律打交道。 第二，项目管理工作。核心都是做事，都是基于规则和规范的。 第三，和下级合作。和下级的合作和沟通就变成了完全和人打交道了，可以利用你的职位和角色带来的职权。 第四，和上级合作。不确定性高。自己很多任务是上级来安排的，这就很被动；上级比自己视野开阔，很多时候揣摩不透上级的意图，但是还不能不关心；自己需要的很多资源和支持都要向上级申请，但不见得能申请到；只能给上级提供建议，但是对方还常常不会采纳。 管理沟通让我们技术管理者们痛苦的主因是确定性和规则性的减弱，不确定性的大幅度上升。 通过如下框架探讨管理沟通。 果见管理沟通框架果见管理沟通框架 \" 果见管理沟通框架 在沟通这个不稳定的事物中，有哪些因素是稳定的： 管理逻辑。随着管理认知和管理经验的不断积累而不断提升的，你的管理逻辑和管理判断力会越来越可靠，应对管理沟通也就越来越有掌控感。 沟通通道。取决于你和对方的信任水平和默契程度。 工具流程。 影响力。 ","date":"2022-05-13","objectID":"/gk-tmp-management-communication/:1:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：管理沟通篇","uri":"/gk-tmp-management-communication/"},{"categories":["Management"],"content":"沟通经常鸡同鸭讲，说不到一块怎么办？ 在沟通中，我们可以使用下图来对齐彼此的信息、感受和意图。 基于 3F 倾听的沟通层次图基于 3F 倾听的沟通层次图 \" 基于 3F 倾听的沟通层次图 ","date":"2022-05-13","objectID":"/gk-tmp-management-communication/:2:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：管理沟通篇","uri":"/gk-tmp-management-communication/"},{"categories":["Management"],"content":"如何掌控自己的情绪，以及如何管理情绪化的员工？ 为方便你管理自己的情绪，抑或者是帮你的下级和伙伴去提升情绪掌控能力，我梳理了整个步骤并总结为如下： 认知它 认同它 觉察它 ","date":"2022-05-13","objectID":"/gk-tmp-management-communication/:3:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：管理沟通篇","uri":"/gk-tmp-management-communication/"},{"categories":["Management"],"content":"向下沟通的常见实例解析 第一类问题，关于“如何批评员工”。不可违背如下三个批评的原则： 人是 OK 的原则。即，对事不对人。批评事，不要打击人，更不能给人贴标签。 具体性原则。指出具体哪里做的不好，让对方容易认同。面向未来的原则。 体现负面的暂时性和过去时，并提供改变的“出口”。 具体应该怎么批评呢？在教练领域有一个 AID 批评法： AID 批评三步法（发展性反馈）AID 批评三步法（发展性反馈） \" AID 批评三步法（发展性反馈） 当你遇到一些不符合期待的问题时，建议先从“我不要……”这种意图中走出来，问问自己“我要什么”。 意图转换流程意图转换流程 \" 意图转换流程 第二类问题，关于和下级员工沟通不顺畅。 对于内向沉默的员工，可以使用下图的“积极引导四步法”。 积极引导四步法积极引导四步法 \" 积极引导四步法 对于总聊不到一个频道上的员工，可以使用我们在第 29 篇文章中介绍的“沟通层次图”。 对于捉摸不透的员工，也可以使用“沟通层次图”或“3F 倾听”来分辨对方表达的内容。 对于如何给员工的表现进行反馈，我推荐使用“主动积极式反馈”。 第三类问题，关于如何应对“牛人”下属。 关于如何和“牛人”技术高工相处，我的心得如下： 高工管理四个要点高工管理四个要点 \" 高工管理四个要点 第四类问题，关于如何应对一些“刺头”员工。 那些需要你付出非常多的时间和精力去管理的员工，叫做“刺头”，也就是管理成本很高的员工。 具体参考下面的“刺头”员工价值评估四象限： 刺头”员工价值评估四象限（果见）刺头”员工价值评估四象限（果见） \" 刺头”员工价值评估四象限（果见） 关于如何促使一个人做出改变，美国学者理查德·贝克哈德的改变公式，可以给我们一些指导： 理查德·贝克哈德的改变公式理查德·贝克哈德的改变公式 \" 理查德·贝克哈德的改变公式 ","date":"2022-05-13","objectID":"/gk-tmp-management-communication/:4:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：管理沟通篇","uri":"/gk-tmp-management-communication/"},{"categories":["Management"],"content":"本文主要是对极客时间《技术管理案例课》二线经理之开始带经理了做的笔记，详细内容可参考：二线经理：开始带经理了。 ","date":"2022-05-13","objectID":"/gk-tmc-second-line-manager/:0:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：二线经理之开始带经理了","uri":"/gk-tmc-second-line-manager/"},{"categories":["Management"],"content":"16 | 冲突管理3：冲突不可怕，可怕的是引发信任危机 ","date":"2022-05-13","objectID":"/gk-tmc-second-line-manager/:1:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：二线经理之开始带经理了","uri":"/gk-tmc-second-line-manager/"},{"categories":["Management"],"content":"提升工作透明度 工作中，常常会因为信息不透明引发信任危机。双方看到的信息不对等，就容易出现一些想当然的看法，还可能因此无端地升级矛盾，导致事情向不可预测的方向发展。 第一，有问题早暴露。 第二，扩大知情范围。 那么有什么更通用的方法，能够提升工作透明度呢，我这里给你梳理了两个要点： 决策透明。把决策的过程和决策依赖的数据和材料发布出来。注意决策透明不代表放弃决策权，最后做决定的那个人还是你。 执行透明。定期公布进度，特别是及时强调阻碍进展的事情，如果需要上级领导注意就直接说出来。千万不要等到影响最终交付的时候再说，那个时候再说就是甩锅了。 ","date":"2022-05-13","objectID":"/gk-tmc-second-line-manager/:1:1","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：二线经理之开始带经理了","uri":"/gk-tmc-second-line-manager/"},{"categories":["Management"],"content":"重要问题当面谈 重要的问题，特别是牵涉到人的问题，用邮件来回交流不如打电话沟通，而且最好是视频电话，当然，如果能和对方面对面坐在一起谈最好。 我的建议就是，把自己的态度摆明，比如说为了跟着领导好好干，我就是需要知道领导的期待；要是和领导的观点不一致，我会私下和领导做沟通，坦诚相告，如果领导没有认同，我会保留意见，对外还是会按照领导说的执行。 ","date":"2022-05-13","objectID":"/gk-tmc-second-line-manager/:1:2","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：二线经理之开始带经理了","uri":"/gk-tmc-second-line-manager/"},{"categories":["Management"],"content":"对下：把话说透，不要让部下猜 ","date":"2022-05-13","objectID":"/gk-tmc-second-line-manager/:1:3","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：二线经理之开始带经理了","uri":"/gk-tmc-second-line-manager/"},{"categories":["Management"],"content":"对上：不要去怀疑领导的初衷 但凡是有些能力和想法的部下，就不大可能对领导所有的决策都认同。但是一定要和领导积极的沟通。 我们的关注点应该是站在领导的角度去看问题，试图理解领导的想法。如果理解不了，就找领导好好地谈一下，问清楚领导的用意。 ","date":"2022-05-13","objectID":"/gk-tmc-second-line-manager/:1:4","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：二线经理之开始带经理了","uri":"/gk-tmc-second-line-manager/"},{"categories":["Management"],"content":"本文主要是对极客时间《技术管理案例课》技术决策者之开始定战略了做的笔记，详细内容可参考：技术决策者之开始定战略了。 ","date":"2022-04-23","objectID":"/gk-tmc-technical-decision/:0:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：技术决策者之开始定战略了","uri":"/gk-tmc-technical-decision/"},{"categories":["Management"],"content":"3. 技术决策（3）：持续跟进进度，执行细节决定成败 关键路径的关键细节一定要把控好。 做完决策就可以了吗？如果我们觉得决策做完了就万事大吉，那么常常就会有这样的后果： 是经理自己被架空。如果不能把握关键细节，完整地跟进进度，经理就容易把自己架空。 会导致业务价值无法按时交付。 无法解决部下的困难。技术经理要了解一线的具体困难，采取行动解决，否则会直接影响到自己的领导力。 只有注重了关键的细节，你才能对你手上的关键产品和项目有比较全面的了解，才能持续地根据实际情况做后续的技术决策。 ","date":"2022-04-23","objectID":"/gk-tmc-technical-decision/:1:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：技术决策者之开始定战略了","uri":"/gk-tmc-technical-decision/"},{"categories":["Management"],"content":"3.1 关键细节如何把握？ 方法一：执行负责人要制定可衡量的阶段性目标 很多事情很难估计时间，强行制定时间表的话最后也许就不能交付。那么很难估计时间的话，目标到底怎么制定呢？ 必须定计划这一条没有商量余地，但是可以做拆分，直到拆分的单元可以很好地做衡量。 具体来说，就是如果季度目标不准就定月度，月度目标不准我们就每两周一次的 Sprint 目标，再不行我们就定每一周的周计划。 方法二：定期的项目评审和周报 定期的作用就是给执行负责人传递一个明确的信号，也就是他的上级技术经理正在持续关注他的进度，愿意及时解决他的实际困难。 同时，这么做对执行负责人也是一种压力，每一次到了项目评审和周报的时间点，他都需要给领导和给同仁看到进度。 关于项目评审和周报有下面三点注意事项： 我不要听流水账，所以负责人要对照项目之前定下的阶段性目标来汇报进度。 如果项目进行过程中有阶段性目标达成，或者有值得肯定和表扬的点，我会要求负责人单独注明。 项目中碰到的问题也需要单独标注，这一条非常重要。我一般会建议执行负责人用绿，黄，红三色来对问题分类。绿色是已经解决的问题，黄色表示虽然出现了问题，但是执行负责人已经拿出了具体的措施在解决问题，目前还不需要上级领导介入，而红色表示要求上级经理介入或者提供帮助。 方法三：不定时地找团队一线骨干做 Deep Dive 通过找团队的一线骨干了解细节，我发现自己对项目的了解更加全面，也能尽快发现实际操作下来经常发生什么样的问题，下面三类问题是最常见的： 第一，对性能压测和失效性分析重视程度不够。我们部门在吃过几次苦头以后，在这一点上已经比较重视了。墨菲定律在我们部门负责的项目上几乎次次灵验。 第二，对关键依赖过于乐观。现在我们部门对于关键依赖我的建议是：没有书面承诺交付时间的，就当这个依赖没有搞定，应该找高级别技术主管介入。 第三，技术实现时夹带必要功能之外的加分项功能。从我们部门目前实际的执行历史看，在核心功能交付前，所有锦上添花的功能都应该全部砍掉。 ","date":"2022-04-23","objectID":"/gk-tmc-technical-decision/:1:1","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：技术决策者之开始定战略了","uri":"/gk-tmc-technical-decision/"},{"categories":["Management"],"content":"3.2 持续跟进的注意事项 决策不等于落实 我们总能轻易举出一系列半途而废的事情，这些事儿都是我们做了决定但是却没有跟进，最后不了了之，没有落实。 第一种情况，就是做了“建议”没有跟进。 我给你举一个具体的例子来说明。我们部门已经多次出现误删操作，因为权限管理太松，发生过不应该有权限的人误操作，结果删除整了个测试数据库的情况。最近一次是因为数据质量问题，系统误删了生产环境流量入口，幸好部署了高可用 HA 防护才没有出大事。 我做复盘的时候，想起我虽然一次一次建议要引入保底措施，在删除逻辑中加入流量检查保护。但到目前为止，我只是反复在强调不采取措施的风险，这个风险就是一旦出问题影响业务，会导致打乱我们所有的原定计划，然后全员都要去做系统可靠性强化工作。 第二种情况，就是没有落实标准。在我们部门最常见的就是出了一个生产事故，于是在风头上大家都很重视，制定出一系列举措。问题是我们很少会去重现那个生产事故，通过测试进一步确认我们落实的那些举措的有效性，也就是在下一次发生类似事故时，我们指定的举措是否真正能够起作用。 比如说我们上个月发生的一件事儿，因为一个 BUG，PaaS 系统的一个超级账号抹掉了整个测试环境监控系统，这个事故我们花了四个小时才恢复服务。 在复盘会议上，团队成员觉得以后我们可以在 20 分钟内恢复服务，但这个想法没有落实到测试环境中检验，其实很难立住脚。 所以我明确要求监控组一定要复制一套一模一样的线上系统，再做一遍删除系统后恢复的模拟测试。要知道，我们设想中可以 20 分钟完成的恢复操作，和真的做一遍，验证一下在 20 分钟内能不能恢复是不一样的。 经理也是执行者 就算我们已经给关键项目安排了负责人，作为主管经理，我们同样也是执行者。领导的工作不单单是给你分配任务，也包括帮你解决你的困难，领导最不希望看到的就是到了快交付了你跟领导说因为这样那样的原因，项目不能如期交付。 所以，如果你觉得有风险需要领导介入，就应该第一时间跟领导沟通。你要有这个气场可以给领导安排工作。 就是因为我认为经理本身也是执行者，关于这个问题，我有三条原则和你分享： 如果部下反映了问题，我能够解决的必须马上解决，不能拖，更不能石沉大海。 如果部下反映的问题我不能马上解决，那我需要告诉部下我大概在什么时候可以解决。 如果我评估下来我也无力解决，我会告诉部下不能解决的原因。 作为领导，要给部下反馈和采取后续动作，做得好的不要吝惜表扬，碰到问题了领导也是执行者需要切实解决困难。 早点到真实环境历练 我们都知道，管理“未知”是最难的，有时候我们可以预判后面执行还会有这样那样的问题，但这些问题你是很难事前预料的，这时候应该怎么办呢？我的做法就是早点放到真实环境去历练，争取尽早暴露问题。 通过关键细节做人员选育 我认为重要的关键项目除了交付业务价值，另一个重要作用就是培养人才。那具体怎么培养呢？ 我最近半年最大的收获就是指出关键细节上的差距。技术主管只有深入一线了解关键细节，才有可能对执行这些项目中的骨干提出有建设性的高质量意见。这些意见对于项目骨干的成长意义重大。 这么做的好处是当你给具体的细节的时候，听的人其实已经从具体的实例中自己得出了你想要的结论，这时候你再说出结论，就更容易被听的人接受。 这个抓细节的思路我也应用到了自己培养部下能力的过程中。比如我跟经理 X 确定了他今年必须有一个目标，这个目标是培养他的左右手到没有他在也能独当一面的水平；我还找到我们部门的技术骨干 E，跟他探讨一下为什么我们部门的关键项目不能由一名骨干带上一批派遣人员来实施，而兄弟部门却可以。 ","date":"2022-04-23","objectID":"/gk-tmc-technical-decision/:1:2","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：技术决策者之开始定战略了","uri":"/gk-tmc-technical-decision/"},{"categories":["Management"],"content":"3.3 总结 我的建议是，对我们的骨干要高标准、严要求，而指出他们的问题时，就要拿出具体的细节上的差距。高标准严要求，甚至是用严厉的语气明确说出来哪个具体的点做得不够好，这对唤醒人的自我觉悟，提升人的能力帮助很大。 ","date":"2022-04-23","objectID":"/gk-tmc-technical-decision/:1:3","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：技术决策者之开始定战略了","uri":"/gk-tmc-technical-decision/"},{"categories":["Management"],"content":"本文主要是对极客时间《技术管理实战 36 讲》任务执行篇做的笔记，详细内容可参考：任务执行篇。 ","date":"2022-04-23","objectID":"/gk-tmp-task-execution/:0:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：任务执行篇（管理三部曲之三）","uri":"/gk-tmp-task-execution/"},{"categories":["Management"],"content":"0. 总纲 在做事之前，我们需要回答的问题是：要做哪些事？先做哪件，后做哪件？也就是分清楚轻重缓急，也叫优先级梳理。 在做事过程中，我们要确保事情的进展按照计划推进，尽在掌握之中，也就是有效地推进执行。 在做事之后，我们要复盘做事的整个过程，并从过去的经验之中抽取一些流程机制，以便以后在类似的场景下也可以做得更好、更顺畅。 任务管理三要素：事前的轻重缓急，事中的有效执行，事后的流程机制。 ","date":"2022-04-23","objectID":"/gk-tmp-task-execution/:1:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：任务执行篇（管理三部曲之三）","uri":"/gk-tmp-task-execution/"},{"categories":["Management"],"content":"1. 多任务并行该如何应对 当安排的工作非常多的时候，由于大家的精力有限，所以需要考虑要优先保证哪项工作的顺利进行。可以通过“重要紧急四象限”去考虑。 重要紧急四象限重要紧急四象限 \" 重要紧急四象限 重要紧急 \u003e 不重要紧急 \u003e 重要不紧急 \u003e 不重要不紧急 如何判定事情是否重要紧急？ 如果做，收益是否很大？收益越大，这个事情就越重要。 如果不做，损失是否很大？损失越大，这个事情就越紧急。 现实工作中更多考虑的是两种情形：一种是计划内的，也就是按照我们的规划进行的；另外一种是计划外的，即突发的情况和任务。 对于任何工作任务，决策的步骤就两步： 对于“计划内工作”，看收益是否足够大。收益越大就越重要，也就越需要给予相匹配的优先级、资源和关注度；收益相对不大，就放入“To do list”，作为待办任务处理。 对于“计划外的工作”，看损失是否足够大。损失够大，就按照紧急任务安排，以止损为核心目的；如果损失可控，就放入“计划内工作”列表。 重要紧急四象限果见版 重要紧急四象限重要紧急四象限 \" 重要紧急四象限 关于任务优先级的安排，除了决策的步骤和方法，还有几个重要的原则： 目标是需要一以贯之的。目标越明确，在关键时刻我们的方向感就越强。 任务安排是弹性的。根据进度、质量、效果的不同期待，你可以给出很多种排期方案。这体现一个管理者的经验是否丰富。 沟通是不可或缺的。只有和所有相关的人员充分沟通了之后，才算是调整完毕，尤其是和自己的上级，一定要和他沟通新的工作安排方案。告诉他，你优先保证了什么，从而可能会影响什么。上级倾向于告诉你，每件工作都是重要的，都是要正常推进的。你要清楚上级最核心的期待是什么，从而去完成什么。 ","date":"2022-04-23","objectID":"/gk-tmp-task-execution/:2:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：任务执行篇（管理三部曲之三）","uri":"/gk-tmp-task-execution/"},{"categories":["Management"],"content":"2. 如何确保项目的有效执行 关于如何确保项目的有效执行，我们有两个探讨的角度。 第一个角度是充分条件视角，即，列出有效执行的所有要点，大家照着做就可以把项目执行好。这个基本实现不了，所以这一角度无需考虑。 第二个角度是必要条件视角，即，我们探讨出一些要点，在项目执行中，只要有一个要点没有做到，项目就很难得到有效的实施。我们把这些要点整理出来，为我们的项目执行提供有价值的参考。 有效执行四要素：目标清晰、责任明确、机制健全和沟通到位。 有效执行四要素有效执行四要素 \" 有效执行四要素 为了提升可操作性，四个要素可扩展为 12 个问题。任务执行时，可以参照下图，对症下药。 任务执行检查清单任务执行检查清单 \" 任务执行检查清单 ","date":"2022-04-23","objectID":"/gk-tmp-task-execution/:3:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：任务执行篇（管理三部曲之三）","uri":"/gk-tmp-task-execution/"},{"categories":["Management"],"content":"3 如何让流程机制得到有效的执行 要想让员工分担我们手头上的工作，要么靠梯队，要么靠机制。 梯队：团队里有胜任度非常好的人，可以帮我们搞定这件事，并且这个人已经是这方面可靠的梯队人才。 机制：设计一套方案，来专门应对某个场景出现的问题，这套方案可以指导和“搀扶着”员工做好这类工作。从而减轻管理者的负担和精力开销。关于这点，个人有三点感受： 建立标准的 SOP 文档。有了标准的 SOP 文档，即使真正执行这个项目的人不在时，我们也可以参照 SOP 文档，完成好各项工作。 周会项目沟通。通过每周项目沟通会，让大家熟悉团队各个成员各自在做的事情，从而达到组内成员对组内整体项目有个熟悉度的把控。 定期技术分享。组内成员可以定期分享自己最近碰到的问题或者新技术，从而提升团队的整体战斗力。 那么，机制要怎么建呢？ 形不形成文档不是关键，很多文档整理出来也发挥不出作用。如果让你检查员工的工作，你检查哪几个点？即你要列清楚你要检查的点，基于这些点去看团队成员的完成度是否满足自己的要求，这才是一套合理的机制。 授权机制涉及到的五个步骤： 首先要明确该机制要解决什么场景下的什么问题，即明确目标。机制的一大特点，就是场景化特性非常明显，因为它们都是为了应对好特定场景下的问题而产生的。所以，你建立一个机制时，首先要描述清楚场景是什么。比如 SOP 手册的建立，针对项目的 DR 切换、扩容及日常排障就是一个很好的机制。 提炼应对该场景的关键点。和一个步骤完整的文档相比，关键点的提炼更为重要，这会让执行成本降低，也更有可操作性。 明确由谁来确保机制的执行，即谁在什么时候检查什么关键点。如果少了这个监督者，流程和机制的有效性就得不到保证。所以，每个机制，都要设立监督者或检查者。 确认操作成本。如果建立的机制反而给执行者带来更大的操作成本，那你就得反思这个机制建立的必要性。 沟通，并和其他执行人取得共识。由于机制的制定者和执行者常常不是同一个人，所以，该机制是否有效，以及能否实施，需要和其他执行人沟通，并达成一致。 要想让机制具有可执行性，建立机制时还要遵循如下的四个原则： 可操作，即简单原则。机制要以最小的学习成本和操作成本为原则，这是最首要的原则。不具备操作性的机制是没有意义的。 只打关节点，即关键原则。你只要告诉大家，在哪几个最关键的节点，做什么样的动作即可，而且这样的关键点也不能太多，以不超过 5 个为宜。这样做可以大大降低执行成本，提升机制的可操作性。 明确到人，即问责原则。 从 case 中来，到 case 中去，即实用原则。每一个机制都要有实用价值。由于机制都是有场景化特性的，当场景发生了变化，机制也要随着升级，而对于机制的重新审视和学习都意味着额外的开销，所以，每个机制的维护都是有成本的。 作者分享的两个关于机制的观点。 机制不是越多越好，而是越少越好。机制的建立、执行和后期维护都是需要成本的，所以，千万不要贪多，在风险可控的前提下，机制能不建就不建，能少则少。 关于到底是人靠谱还是机制靠谱。机制的意义就在于，当人不靠谱时，事情也不至于变得很差。所以，机制是为了保证做事的“下限”的。同时，机制有很好的迁移性和传承性，不会随着某个人的缺位而产生大的影响。因此，必要的机制是不可或缺的。 ","date":"2022-04-23","objectID":"/gk-tmp-task-execution/:4:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：任务执行篇（管理三部曲之三）","uri":"/gk-tmp-task-execution/"},{"categories":["Linux"],"content":"本文主要分析了当 linux 系统中出现 too many open files 问题时，我们应该如何去解决这类问题。 ","date":"2022-04-23","objectID":"/linux-too-many-open-files/:0:0","tags":["Linux"],"title":"如何解决 linux too many open files 问题","uri":"/linux-too-many-open-files/"},{"categories":["Linux"],"content":"1. 带来的问题 如果出现 too many open files 会带来什么呢？ 应用程序进程启动不了。 应用程序进程崩溃。如下图所示，docker 进程崩溃。 dockerd 进程崩溃dockerd 进程崩溃 \" dockerd 进程崩溃 ","date":"2022-04-23","objectID":"/linux-too-many-open-files/:1:0","tags":["Linux"],"title":"如何解决 linux too many open files 问题","uri":"/linux-too-many-open-files/"},{"categories":["Linux"],"content":"2. 产生原因 too many open files（打开的文件过多）是 Linux 系统中常见的错误，从字面意思上看就是说程序打开的文件数过多，不过这里的 files 不单是文件的意思，也包括打开的通讯链接（比如 socket），正在监听的端口等等，所以有时候也可以叫做句柄（handle），这个错误通常也可以叫做句柄数超出系统限制。 引起的原因就是进程在某个时刻打开了超过系统限制的文件数量以及通讯链接数，通过命令 ulimit -a 可以查看当前系统设置的最大句柄数是多少。1 ","date":"2022-04-23","objectID":"/linux-too-many-open-files/:2:0","tags":["Linux"],"title":"如何解决 linux too many open files 问题","uri":"/linux-too-many-open-files/"},{"categories":["Linux"],"content":"3. 通过命令进行问题分析 ","date":"2022-04-23","objectID":"/linux-too-many-open-files/:3:0","tags":["Linux"],"title":"如何解决 linux too many open files 问题","uri":"/linux-too-many-open-files/"},{"categories":["Linux"],"content":"3.1 查看系统目前允许单个进程打开的最大句柄数 $ ulimit -a ulimit -a 示意图ulimit -a 示意图 \" ulimit -a 示意图 其中 open files (-n) 65536 表示单个进程最大允许打开的句柄数是 65536。 ","date":"2022-04-23","objectID":"/linux-too-many-open-files/:3:1","tags":["Linux"],"title":"如何解决 linux too many open files 问题","uri":"/linux-too-many-open-files/"},{"categories":["Linux"],"content":"3.2 查看当前进程打开了多少个文件句柄 $ lsof -n | awk '{print $2}' | sort | uniq -c | sort -nr | more 当前进程打开了多少个文件句柄当前进程打开了多少个文件句柄 \" 当前进程打开了多少个文件句柄 图中 3530 表示进程 ID，1804 表示打开文件句柄数。 ","date":"2022-04-23","objectID":"/linux-too-many-open-files/:3:2","tags":["Linux"],"title":"如何解决 linux too many open files 问题","uri":"/linux-too-many-open-files/"},{"categories":["Linux"],"content":"3.3 查看单个进程打开了多少个文件句柄 $ lsof -n 3530 单个进程打开了哪些文件句柄单个进程打开了哪些文件句柄 \" 单个进程打开了哪些文件句柄 $ lsof -n 3530 | wc -l 单个进程打开了多少个文件句柄单个进程打开了多少个文件句柄 \" 单个进程打开了多少个文件句柄 ","date":"2022-04-23","objectID":"/linux-too-many-open-files/:3:3","tags":["Linux"],"title":"如何解决 linux too many open files 问题","uri":"/linux-too-many-open-files/"},{"categories":["Linux"],"content":"4. 解决办法 ","date":"2022-04-23","objectID":"/linux-too-many-open-files/:4:0","tags":["Linux"],"title":"如何解决 linux too many open files 问题","uri":"/linux-too-many-open-files/"},{"categories":["Linux"],"content":"4.1 命令式：增大允许打开的文件数1 $ ulimit -n 2048 这样就可以把当前用户的最大允许打开文件数量设置为 2048 了，但这种设置方法在重启后会还原为默认值。 ulimit -n 命令非 root 用户只能设置到 4096。 想要设置到 8192 需要 sudo 权限或者 root 用户。 ","date":"2022-04-23","objectID":"/linux-too-many-open-files/:4:1","tags":["Linux"],"title":"如何解决 linux too many open files 问题","uri":"/linux-too-many-open-files/"},{"categories":["Linux"],"content":"4.2 修改系统配置文件：增大允许打开的文件数1 $ vim /etc/security/limits.conf # 在最后加入 * soft nofile 4096 * hard nofile 4096 或者只加入 * - nofile 8192 最前的 * 表示所有用户，可根据需要设置某一用户，例如 leslie soft nofile 8192 leslie hard nofile 8192 注意：nofile 项有两个可能的限制措施。就是项下的 hard和 soft。要使修改过得最大打开文件数生效，必须对这两种限制进行设定。如果使用 - 字符设定, 则 hard 和 soft 设定会同时被设定。 ","date":"2022-04-23","objectID":"/linux-too-many-open-files/:4:2","tags":["Linux"],"title":"如何解决 linux too many open files 问题","uri":"/linux-too-many-open-files/"},{"categories":["Linux"],"content":"4.3 检查程序问题 如果你对你的程序有一定的解的话，应该对程序打开文件数（链接数）上限有一定的估算，如果感觉数字异常，请使用第一步的 lsof -p 进程id \u003e openfiles.log 命令，获得当前占用句柄的全部详情进行分析。 分析步骤 1）打开的这些文件是不是都是必要的？ 2）定位到打开这些文件的代码 3）是否程序操作了文件写入，但是没有进行正常关闭 4）是否程序进行了通讯，但是没有正常关闭(也就是没有超时结束的机制) 如果程序中存在这些问题的话，无论系统句柄数设置的多么大，随着时间的推移，也一定会占用完。 ","date":"2022-04-23","objectID":"/linux-too-many-open-files/:4:3","tags":["Linux"],"title":"如何解决 linux too many open files 问题","uri":"/linux-too-many-open-files/"},{"categories":["Linux"],"content":"5. 参考文献 [1] https://blog.csdn.net/Roy_70/article/details/78423880. [2] https://matianxin.github.io/2020/06/01/Linux/TooManyOpenFiles. ","date":"2022-04-23","objectID":"/linux-too-many-open-files/:5:0","tags":["Linux"],"title":"如何解决 linux too many open files 问题","uri":"/linux-too-many-open-files/"},{"categories":["Management"],"content":"本文主要是对极客时间《技术管理案例课》一线经理之开始带员工了做的笔记，详细内容可参考：一线经理之开始带员工了。 ","date":"2022-04-22","objectID":"/gk-tmc-first-line-manager/:0:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：一线经理之开始带员工了","uri":"/gk-tmc-first-line-manager/"},{"categories":["Management"],"content":"06 员工沟通：怎么赢得之前平级的技术骨干的尊重？ ","date":"2022-04-22","objectID":"/gk-tmc-first-line-manager/:1:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：一线经理之开始带员工了","uri":"/gk-tmc-first-line-manager/"},{"categories":["Management"],"content":"经理的目标 经理的目标是让团队的成员更强，凝聚力更高，从而可以一起去攻克更艰难的目标，而不是证明你比你的部下或者平级更强。如果你沉浸在“让自己最强”的表象中，就会导致一个问题——你的水平会成为整个团队的瓶颈。 ","date":"2022-04-22","objectID":"/gk-tmc-first-line-manager/:1:1","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：一线经理之开始带员工了","uri":"/gk-tmc-first-line-manager/"},{"categories":["Management"],"content":"如何赢得尊重？ 给干将搭台子 第一，给充分的资源支持。对外，持续把员工推出去，让他们去负责解决这个强需求点。对内，努力去跟相关的高级总监、副总去谈，去找需求、要资源、要认可，让他们获得真正的成长。 第二，让员工有被需要的感觉，让他感觉自己在这个团队里“独一无二”。你可以这么说，“这件事很有意义，但是也很难，就我们组织目前的人员配置，只有你最有可能搞定这件事，我没有别的选择，只能靠你。”但是不可马上希望看到回报。 克服心理屏障 你给员工提意见和建议的时候不要空谈，要不绕弯子地谈具体的细节。了解得越详细，你提意见的时候也就越有底气。 必须克服心理障碍直指他们的问题，我前面说了，目的不是压得住压不住，而是为了这个团队更好，为了这个员工好。 提升自己的能力 如果你团队里有能力强的员工，这是对你自己提高自己能力的一个鞭策，你可以把团队中能力强的员工当成使自己更快提高的磨刀石！ 那怎么提升自己的能力呢？最有效的方法就是去经历挫折，主动去走出舒适区。 ","date":"2022-04-22","objectID":"/gk-tmc-first-line-manager/:1:2","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：一线经理之开始带员工了","uri":"/gk-tmc-first-line-manager/"},{"categories":["Management"],"content":"07 | 向上管理：你知不知道你领导真正的烦恼是啥？ ","date":"2022-04-22","objectID":"/gk-tmc-first-line-manager/:2:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：一线经理之开始带员工了","uri":"/gk-tmc-first-line-manager/"},{"categories":["Management"],"content":"对内：把上级纳入你的团队 把上级纳入你的团队把上级纳入你的团队 \" 把上级纳入你的团队 ","date":"2022-04-22","objectID":"/gk-tmc-first-line-manager/:2:1","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：一线经理之开始带员工了","uri":"/gk-tmc-first-line-manager/"},{"categories":["Management"],"content":"拔高层级看问题 你要有站在领导的角度去看问题的意识，甚至你还要进一步，站在高你两级的领导的角度去看问题。 ","date":"2022-04-22","objectID":"/gk-tmc-first-line-manager/:2:2","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：一线经理之开始带员工了","uri":"/gk-tmc-first-line-manager/"},{"categories":["Management"],"content":"帮领导排忧解难 主动换位思考，去体会领导面临的问题，体会领导的烦恼，然后是你想不想帮的态度问题，也就是你有没有想到要去做些什么，来帮助领导。 ","date":"2022-04-22","objectID":"/gk-tmc-first-line-manager/:2:3","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：一线经理之开始带员工了","uri":"/gk-tmc-first-line-manager/"},{"categories":["Management"],"content":"不做奴才部下 不能在领导面前唯唯诺诺，领导说一就是一，领导说二就是二。我应该是一个有独立思考，能够跟领导进行高质量沟通的部下。 我觉得跟老板相处，要带着“一颗支持的心去提反对的问题”。 下面是一些技巧，你可以按照这些思路和领导进行高质量的沟通： 和领导高质量沟通的思路和领导高质量沟通的思路 \" 和领导高质量沟通的思路 ","date":"2022-04-22","objectID":"/gk-tmc-first-line-manager/:2:4","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：一线经理之开始带员工了","uri":"/gk-tmc-first-line-manager/"},{"categories":["Management"],"content":"不做无能部下 最好的状态是：领导可以在一个很放松的状态下跟你谈话，他指出你的问题不需要经过取证，准备的过程，他可以说，你可以解释。也就是说他也没有负担，你也没有负担。 ","date":"2022-04-22","objectID":"/gk-tmc-first-line-manager/:2:5","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：一线经理之开始带员工了","uri":"/gk-tmc-first-line-manager/"},{"categories":["Management"],"content":"对外：学会感恩，维护领导 ","date":"2022-04-22","objectID":"/gk-tmc-first-line-manager/:2:6","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：一线经理之开始带员工了","uri":"/gk-tmc-first-line-manager/"},{"categories":["Management"],"content":"维护领导权威 我的原则是这些问题都是你和领导之间的事情，因此你绝对不应该在自己的部下面前，或者在旁人面前对自己的直属领导说三道四。 ","date":"2022-04-22","objectID":"/gk-tmc-first-line-manager/:2:7","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：一线经理之开始带员工了","uri":"/gk-tmc-first-line-manager/"},{"categories":["Management"],"content":"别让领导做坏人 ","date":"2022-04-22","objectID":"/gk-tmc-first-line-manager/:2:8","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：一线经理之开始带员工了","uri":"/gk-tmc-first-line-manager/"},{"categories":["Management"],"content":"懂得感恩 ","date":"2022-04-22","objectID":"/gk-tmc-first-line-manager/:2:9","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：一线经理之开始带员工了","uri":"/gk-tmc-first-line-manager/"},{"categories":["Management"],"content":"09 | 人才培养：御人也是育人，人才培养的5个维度 怎么做好人才培养这件事？ ","date":"2022-04-22","objectID":"/gk-tmc-first-line-manager/:3:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：一线经理之开始带员工了","uri":"/gk-tmc-first-line-manager/"},{"categories":["Management"],"content":"积极主动，态度先行 考虑问题的时候应该从领导的角度、从组织的角度来看，而不是单单从自己的角度来看。 优秀的员工不是坐等领导安排工作，而是会主动去发现问题，去理清问题，他会跟领导说这个问题我考虑过很多种解决方案，优劣的分析结果在这里，我觉得应该选方案 X，原因是 ABC。 员工自由度层次员工自由度层次 \" 员工自由度层次 怎样激发大家的积极主动性？ 第一步，明确标准，告知期待。包括内容和程度两个维度的期待。 第二步，赏罚分明，落地要求。 第三步，循序渐进，带头提升。经理作为团队的带头人，自己做事儿就要注意积极主动性。经理也要主动约自己的上级做工作汇报。 ","date":"2022-04-22","objectID":"/gk-tmc-first-line-manager/:3:1","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：一线经理之开始带员工了","uri":"/gk-tmc-first-line-manager/"},{"categories":["Management"],"content":"实战积累为主 之前的学习方法一直就是先彻底搞清楚理论，再动手。我发现当时花了很多时间，但只是纸上谈兵，没产生什么实际效果。 必须先动手，一边干一边学。学 React ，自己去拿一个项目练练手，先学会怎么用再去查资料搞清楚原理。 注意点：控制压力。第一：配合定期谈心。第二：师傅带新人。 ","date":"2022-04-22","objectID":"/gk-tmc-first-line-manager/:3:2","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：一线经理之开始带员工了","uri":"/gk-tmc-first-line-manager/"},{"categories":["Management"],"content":"提高软实力 经理和技术骨干要跟员工做真实工作的情境模拟。 要给一些鼓励。比如经理可以鼓励员工对领导直抒己见。 ","date":"2022-04-22","objectID":"/gk-tmc-first-line-manager/:3:3","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：一线经理之开始带员工了","uri":"/gk-tmc-first-line-manager/"},{"categories":["Management"],"content":"给员工提供专注的机会 一个人什么事儿都做但方向上总是换来换去，和他在某一方向上专注发展三年不换方向，明显是后一个情况他更有可能成为所选方向上的专家。 自身后期也必须在某个方向上深耕，至少保持三年以上，这样才能成为某个领域的专家。 ","date":"2022-04-22","objectID":"/gk-tmc-first-line-manager/:3:4","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：一线经理之开始带员工了","uri":"/gk-tmc-first-line-manager/"},{"categories":["Management"],"content":"把握“挫折”的度 经历挫折是促使自己成长最快最有效的方式。 做经理的可以接受一两件事情没有做成，但是不希望员工的自信给打击没了。 到底怎么掌握度呢？ 逐步提高难度。 压一压被培养人的耐受性，评估他的心理承受力在哪个点上。 无论用哪一种方式，都要保持跟被培养人的频繁沟通。 做经理的不愿意授权，担心这个做不好，那个不完美，员工就永远也成长不起来。 ","date":"2022-04-22","objectID":"/gk-tmc-first-line-manager/:3:5","tags":["Management","Note","Geek"],"title":"[笔记]技术管理案例课：一线经理之开始带员工了","uri":"/gk-tmc-first-line-manager/"},{"categories":["Management"],"content":"本文主要是对极客时间《技术管理实战 36 讲》团队建设篇做的笔记，详细内容可参考：团队建设篇。 ","date":"2022-04-22","objectID":"/gk-tmp-team-building/:0:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：团队建设篇（管理三部曲之二）","uri":"/gk-tmp-team-building/"},{"categories":["Management"],"content":"团队建设该从哪里入手？ 团队建设时 6 个维度的工作要素： 针对员工个体的两个要素是：能力和激励； 针对员工个体之间的两个要素是：分工和协作； 针对团队整体的两个要素是：梯队和文化。 团队建设六要素团队建设六要素 \" 团队建设六要素 ","date":"2022-04-22","objectID":"/gk-tmp-team-building/:1:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：团队建设篇（管理三部曲之二）","uri":"/gk-tmp-team-building/"},{"categories":["Management"],"content":"如何提升员工的个人能力？ 能力划分方法一：知识、技能和才干。 能力三核能力三核 \" 能力三核 能力划分方法二：人格力量、专业能力和通用能力。 工作能力三维视图工作能力三维视图 \" 工作能力三维视图 人格力量：指一个人在面对某一情形时稳定的态度和表现，比如迎难而上、坚持不懈、积极正向、主动担当等等。 专业能力：一般就是指技术能力。 通用能力：沟通表达能力、团队协作能力、快速学习能力等等。 对于一个人的评价标准： 及格：能够胜任工作的要求。如果连这个都不能达到，需要尽早淘汰。 优秀：除了胜任工作要求，还需要脱颖而出，超出团队普通表现，成为整个团队的核心人物。 如何帮助员工提升个人能力，7-2-1 法则，70% 工作实践，20% 靠相互交流和讨论，10% 靠听课和看书自学。 第一类，关于帮助员工自学： 组织员工参加培训 为员工推荐和购买书籍 提供学习文档、视频等 第二类，关于相互交流讨论： 组织兴趣小组、读书会等 技术分享交流会、代码评审会等 重点工作复盘，即 case study 等 第三类，关于工作实践： 授权和辅导。给员工独立负责重要工作的机会，并给予辅导和反馈。 调研工作项目化。即把调研学习的工作进行项目化管理。 总结并内化。对于员工完成的重要工作，有必要请他们做一个工作总结，看看从中学到了什么。员工在这个总结和反思过程中的收获，甚至比总结的结果本身更重要。 如何激发员工学习的动力和意愿呢？三板斧：推、拉、放手。 推：给压力，推着他们学。 提出明确的工作要求。比如，在 1 周内熟悉某个业务并可以做开发。 设置学习机制。也就是强制要求遵守学习规则，并完成学习任务。 peer pressure。团队整体学习成长的氛围，会给不学习的员工带来压力。 惩罚。包括从绩效等级、晋升机会、调薪幅度等等，对于学习意愿低的员工有适当的“关照”。 拉：就是给方向，引导他们学。 树立榜样。把特别有学习意愿和成长快速的员工设为标杆人物，在团队内给予认可和奖励。 配备导师。有明确导师的新人和员工，更愿意请教问题并快速融入团队。新人导师最好是团队内的，而资深员工的导师，可以找团队外更资深的人。 给地图。成熟的公司往往会有技术方面的“技能图”，作为管理者，你也可以为自己团队制定一个成长的“技能图”，并标记出重要等级。这样，团队成员就有了学习和成长的方向，知道该往哪里使劲了。 放手：就是给发挥空间，让他们自主学习。 给员工勇挑重担的机会。在风险可控的情况下，给员工承担责任的机会，让他们去负责一些有挑战的工作。 给员工自主空间，让他们独立思考，独立决策。你的辅导仅限于在他们的决策之后给出看法和建议。 给员工信心和耐心，允许他们犯错、走弯路。因为很多经验都是踩坑儿踩出来的，所以不能一出问题就劈头盖脸一顿批，甚至是剥夺其做事的机会。 关于提升员工的能力，有两个信念特别重要。 第一是相信员工能力的差异性。员工的创造力能为团队带来更大的价值。创造力往往来源于差异的碰撞，所以作为管理者，你要特别关注能力的丰富性，标准不能太单一。 第二是相信团队能力的系统性。所谓完美的团队，就是价值观相同，优势互补的团队。所以，作为管理者，你要看到团队能力的系统性，不要把各个员工的能力割裂来看。 ","date":"2022-04-22","objectID":"/gk-tmp-team-building/:2:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：团队建设篇（管理三部曲之二）","uri":"/gk-tmp-team-building/"},{"categories":["Management"],"content":"如何提升员工的工作意愿和积极性？ 归结起来，不外乎是如下三个问题： 第一，激励认知不系统。不清楚激励都有哪些手段，以及如何使用，各种零散的说法让人无所适从。 第二，激励可用资源匮乏。实实在在的物质激励不受自己掌控，画大饼的精神激励，员工又不买账。 第三，激励达不到效果。虽然激励的动作都做到位了，但是并没有收到激发员工动力的效果，或者效果不够令人满意。 ","date":"2022-04-22","objectID":"/gk-tmp-team-building/:3:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：团队建设篇（管理三部曲之二）","uri":"/gk-tmp-team-building/"},{"categories":["Management"],"content":"激励的系统认知 驱动力 2.0。采取的方案是“奖励好的行为、惩罚坏的行为”，也就是人们经常念叨的“胡萝卜加大棒”。效果还不错，但就是越用效果越差。因为无论是奖励还是惩罚，这类驱动力最大的特点是来自外部刺激。对于这类方法的改进： 具体。就是表扬的内容和原因要非常具体，让员工和团队都知道他是因为哪一两点得到了认可。比如“员工 A 非常主动及时地处理了一个线上故障”“员工 B 在带新员工方面成绩突出”等。这样做，大家就能够清晰地接收到你在倡导什么，而且还能有效防止对没有受到表扬的人造成负激励。 公开。公开表扬有两大好处，一个是被表扬的同学受到了更大的激励；另外一个更大的好处是，你其实告诉了团队每个人，什么样的行为和价值观在你们团队是被认同和倡导的。 及时。所有的期待都有时效性，表扬及时，其实就是对员工的反馈要及时。一个不及时的表扬不但会让激励效果大打折扣。 驱动力 3.0。驱动力 3.0 的核心就在于自驱力。怎么激发员工的自驱力呢？ 第一，提升员工工作的自主性。即，给员工一定程度的自主掌控感。 工作时间和地点上的自由度。把焦点放在对结果的评价上，而不是把焦点放在员工的作息习惯上。 工作内容上的自由度。员工可以在一定程度上选择自己的工作内容。Google 原来有个“20% 自由时间”的策略，即员工有 20% 的工作时间可自由支配，很受工程师们的热捧。 工作方法上的自由度。 第二，提升员工专精度，让员工持续有成长。这里专精度是指为员工创造愿意自主投入的条件，因为只有自主投入才能带来专精。 明确的工作目标。即，对员工的要求越清晰，他就越愿意投入努力。 目标要略有挑战。即，对员工的要求要有一定挑战，但又不能太高。要求太高带给员工的是焦虑；要求太低带给员工的是无聊。 要能发挥其优势。每个人都愿意做自己擅长的事情，如果某项工作能发挥员工的独特优势，必定会给他带来投入的热情。 优势层次图优势层次图 \" 优势层次图 第三，给予员工意义和使命。驱动力 3.0 在不拒绝利益的同时，更强调的是工作价值的最大化，希望自己做出来的工作是有意义和价值的。 管理者的一项重要修炼，就是去梳理团队的使命和项目的意义。 记得文中那个测试经理的案例吗？当他明白了自己团队不仅仅是做测试的，更是整个公司产品和服务质量的保障者之后，激发了他持续的工作热情，这就是意义的价值。 虽然驱动力 2.0 的激励效果在不断打折扣，但是基本的奖惩还是要做到位，这是基线。 驱动力发展三阶段驱动力发展三阶段 \" 驱动力发展三阶段 积极心理学全面可持续幸福模型（PERMA）积极心理学“全面可持续幸福”模型（PERMA） \" 积极心理学全面可持续幸福模型（PERMA） ","date":"2022-04-22","objectID":"/gk-tmp-team-building/:3:1","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：团队建设篇（管理三部曲之二）","uri":"/gk-tmp-team-building/"},{"categories":["Management"],"content":"激励可用资源匮乏 如果你把“驱动力 3.0”和“PERMA 模型”两个激励框架结合起来使用，你会发现，现在你可用的激励手段已经非常丰富了。 ","date":"2022-04-22","objectID":"/gk-tmp-team-building/:3:2","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：团队建设篇（管理三部曲之二）","uri":"/gk-tmp-team-building/"},{"categories":["Management"],"content":"激励达不到效果 每一个激励方案都需要去思考和设计，把外驱和内驱结合起来，把长期和短期结合起来，把业务推进和职业幸福集合起来，把个人工作和团队使命结合起来。 ","date":"2022-04-22","objectID":"/gk-tmp-team-building/:3:3","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：团队建设篇（管理三部曲之二）","uri":"/gk-tmp-team-building/"},{"categories":["Management"],"content":"如何兼顾团队分工的稳定性和灵活性？ 为什么要分工？ 第一，为了实现规模化。分工不是为了高效，而是为了能容纳更多的人来一起干更大、更复杂的事情，做简单的小事情，是不需要分工的。 第二，为了实现协作。我认为是先有协作的需求，才有分工。换句话说，分工是手段，协作是目的，分工和协作是不能割裂开的。所以，如果你有一个分工方案对协作不利，就本末倒置了。 第三，为了实现专精。精细化分工只需要每个员工关心单一工作内容，所以管理者更容易从整体上用人之长、避人之短，让专业的人更专业。 分工引发很多延伸效果：力资源配置优化、人才获取成本降低、员工工作积极性提升、执行效率变高等。 常见的分工形式：一类是矩阵式的，一类是 BU（BUSINESS UNIT）式的。 矩阵式结构。员工按照角色被划分到不同的团队，每个团队都有自己的负责人。要做项目的时候，会有专门的项目经理来向各个角色的 leader 协调人力，然后把申请到的各个角色的人组织在一起去完成这个特定项目。一旦项目完成之后，人员将回归各自团队去迎接新的项目。 BU 式结构。做某项业务所有的人员和资源都统一调配，无论这个事业部是大是小，都角色齐全。这样做的好处是团队长期合作磨合充分，协作效率高，执行速度快；不足是各种角色自己都要有，资源冗余和浪费比较多。另外，由于某些角色不在业务主干上，团队规模比较小，能力要求也不高，所以其角色专业度很难提升。 分工几个常见的误区、问题和建议原则。 分工模糊。何不以分工清晰为前提的边界模糊化，结果都会事与愿违。为什么呢？因为只有明确的分工，才能让员工清楚和认同自己的本职职责，产生归属感，并愿意主动付出多做一些。 分工稳定性。被动调整（来自外部的业务调整）和主动调整都会造成分工的不稳定。分工能带来专精，同时也带来了割裂的视野，所以很多管理者会通过“轮岗”的方式来提升员工的能力和全局观。 虚拟组织。为了某一个特定的目的和工作内容把大家组织到一起的。 为什么要组建虚拟团队？ 高效执行。为了专人专事，聚焦目标，高效执行。 资源配置。对于很多工作来说，专门组建一个团队不值得，但是又时不时需要立项新项目，虚拟团队就为这类需求提供了解决方案。 保持归属感。虚拟团队本身就带有“借调”的味道，并不影响员工认定自己“本应”的位置在哪里，所以，不会影响员工的归属感。 使用虚拟团队这种方式需要注意的几个原则： 专人专事，不宜太多。表着足够高的重视和足够高的要求，所以对应也要有足够多的资源投入。 认同员工价值。既然你同意你的员工加入这个虚拟组织，无论做出来的业绩是不是你最看重的，都要认可他的价值。 目标明确，职责冠名。每个虚拟组织建立起来都是为了特定的目标，所以你组建每个虚拟团队的目标要非常清晰，并且和团队每个人都要传达到位。为了进一步提升责任感和归属感，很多 leader 会把职责冠在团队名字上，我认为非常好。比如“100 天战队”“用户体验优化小分队”“架构迁移大队”等，很是生动形象。 ","date":"2022-04-22","objectID":"/gk-tmp-team-building/:4:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：团队建设篇（管理三部曲之二）","uri":"/gk-tmp-team-building/"},{"categories":["Management"],"content":"有什么方法可以有效提升团队凝聚力吗？ 如何不断提升团队的协作水平呢？ 第一个角度是建立协作机制，通过机制来约定协作的动作，以此来保证大家“动作协调”。 第二个视角是提升团队凝聚力，通过提升团队成员间的信任度、认同度和默契度来降低协作成本，提高协作效率。 想提升协作水平，“硬件”靠机制，而“软件”靠凝聚力。 那么，如何来提升团队凝聚力呢？ 第一个角度，设立共同愿景。 明确你团队的职责、使命和工作目标。这里的工作目标是长远的共同目标。 管理者自己要笃信第 1 条的内容。如果不笃信，就返回步骤 1 继续提炼。 在各种合适的场合宣贯这一内容，比如季度会、总结会、沟通会、启动会，以及 1 对 1 沟通等，都要不失时机、不突兀地把使命和愿景同步给大家。 坚持不懈地做步骤 3。不要指望一蹴而就，开个会大家就都认同了的好事，现实中不会发生，只有时间长了、频次够了，才会内化，才会深深植入员工的内心。 第二个角度，提升员工归属。 要给他一个位置，给他一个“立足之地”，也就是要分给他一份职责。让员工清楚他肩负的职责对于团队的意义，让他觉得自己做的事有价值，这就是所谓的“事对”。 要营造良好的团队人际关系，让彼此间形成紧密的连接。 明确亮出团队的文化价值观。 第三个角度，加强相互了解。经过设计的活动，不但效果很好，而且还不需要什么经费。比如我曾经尝试给大家做过 1 个小时的“巅峰故事会”：在 1 个小时内，每个人都讲出他们曾经的巅峰体验，然后请队友给出积极反馈。1 个小时下来，产生了很多的化学反应，大家都说比之前更了解对方了，也更接纳对方了。 第四个角度，共同面对挑战。虽然我们现在没有仗要打，但至少有如下两个方面的事情近似打仗： 一些有挑战的大型项目或紧急事故的应对。 跨团队的对抗性活动，比如趣味运动会、Dota 比赛等。 凝聚力四法凝聚力四法 \" 凝聚力四法 ","date":"2022-04-22","objectID":"/gk-tmp-team-building/:5:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：团队建设篇（管理三部曲之二）","uri":"/gk-tmp-team-building/"},{"categories":["Management"],"content":"如何物色和培养核心人才？ ”梯队培养”实际上就是选拨一些人，并把他们培养成团队的核心骨干，也就是团队的“骨架子”。这其中包含了两个部分的工作：一个是选拨和物色培养对象，另外一个是培养这些人。 物色培养对象应该要满足以下两个原则： 第一，要保持人才选拔和团队建设的一致性。 能力。主要是确保其个体能力和业务特点相互匹配，能力潜质是可成长的。比如，对于功能交付的团队，其功能开发质量和效率是否突出；对于算法团队，其算法能力是否良好等。 协作。团队的核心骨干都要有比较好的协作意识，才可以干更大的事情，才可以发挥一个骨干需要发挥的作用。 文化。其行为风格和价值观，和团队文化价值观是否匹配。比如，你团队如果倡导“积极主动”或“自驱”的团队文化，那么一个专业能力很强但是被动的人是否值得你培养？ 第二，和你相似的人才是人才，和你互补的人才是更宝贵的人才。如果说上一条原则我们强调了价值观层面的一致性，那么这条原则就是在强调行为风格和思维方式的多样性。 人才物色出来了，要怎么培养呢？ 第一，对齐期待，达成共识。常用方式是 IDP，即个人发展计划。关于 IDP 的制定，每个公司都有自己的模板，按要求炮制就好。我的习惯是把绩效计划和 IDP 合二为一。 第二，提供机会和发挥空间，做好授权。 工作授权三段法工作授权三段法 \" 工作授权三段法 第三，建立反馈机制。 建立周期性沟通机制。 review IDP。 安排第二导师，给予支持和反馈。 ","date":"2022-04-22","objectID":"/gk-tmp-team-building/:6:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：团队建设篇（管理三部曲之二）","uri":"/gk-tmp-team-building/"},{"categories":["Management"],"content":"如何建设团队文化，营造团队氛围？ 团队文化三步法团队文化三步法 \" 团队文化三步法 ","date":"2022-04-22","objectID":"/gk-tmp-team-building/:7:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：团队建设篇（管理三部曲之二）","uri":"/gk-tmp-team-building/"},{"categories":["Management"],"content":"如何和低绩效员工谈绩效？ 良好的绩效沟通要达到哪些目的？收获哪些价值呢？ 对齐。绩效沟通的过程，其实是很好的对齐双方观点的机会。你们可以互相同步自己的信息，听取对方对于这些事实的看法和判断，了解对方在乎的焦点在哪里，交换双方对于同一个结果的评价标准，等等 辅导。不仅仅是告知员工绩效结果，更重要的是通过对过去工作的回顾，让员工有更多的思考和觉察。 激励。好的绩效沟通，即便对方是低绩效员工，也会通过沟通令他重燃斗志，对未来充满希望，从而达到激励的效果。 绩效沟通如果能达到这三个效果，那就太美妙了，具体要怎么来谈呢？ 第一，首先需要明白的是，绩效沟通的核心并不在于谈，而在于绩效管理全过程的完整性。 绩效计划或绩效评估方案的制定。即，你未来给员工打绩效的依据是什么。 和员工确认绩效计划。即，你和员工都要认同这个评估手段，所以很多公司的绩效计划都是要员工签字的。 归档并维护。可能会因为员工工作内容的重大调整，中期会有一些更新。 绩效评估。你需要对员工在本次绩效周期内的工作表现进行评估和打分。 绩效沟通。就绩效评估结果和员工进行沟通，达到对齐共识、辅导和激励的效果。 你对员工的绩效做评价时，一定要有评价依据，这个依据最好就是一起制定的绩效计划。 第二，在绩效沟通之前，先摆正自己的角色和姿态。 即便他做的也还不错，但是你如果还是把低绩效的名额给了他，那么你一定是有自己的依据的，所以这个绩效也的确是他应得的，你并不欠他什么。你有管理者的职业素养，有管理者的工作视角，也有令人信服的评价依据，你做出来的就是最公平和最恰当的决策。 第三，把绩效沟通当作是承上启下的新起点，而不是末日审判。 如何让这个沟通不那么令人沮丧和压抑呢？引导他多说一些自己对未来的打算，希望接下来做些什么，打算怎做，以及需要哪些支持和帮助。 教练式的引导方式，一起做一场着眼未来的、面向长期发展的绩效沟通，就能收获到辅导和激励的效果。 所有以上的探讨，都基于一个基本假设，就是这个低绩效员工你还希望继续留用。如果你都没有留用他的意愿了，那就不再是一个绩效沟通的问题，而是如何辞退员工的问题了。 ","date":"2022-04-22","objectID":"/gk-tmp-team-building/:8:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：团队建设篇（管理三部曲之二）","uri":"/gk-tmp-team-building/"},{"categories":["Management"],"content":"如何让团建活动不再“收效甚微”？ 管理者安排团建活动的出发点，大体是如下三类： 以团队需要为初衷。比如提高员工积极性、提升团队凝聚力、打造团队文化、提升斗志、提升团队韧劲等。 以员工需要为初衷。常见的是调节放松，一段高强度工作之后，缓解员工的精神压力和紧张情绪。 以个人需要为初衷。比如，认为团建只是一项管理任务，需要时不时执行一次；或者只是单纯出于个人需要。 团队建设六要素团队建设六要素 \" 团队建设六要素 如何才能做出“收效显著”的团建活动呢？团建活动四问法： 第一问，关乎初衷：你是想做团建活动，还是调节放松，或是其他？ 第二问，关乎角色：是你想做团建活动，还是只想配合一下助理、HR 或行政的工作？ 第三问，关乎目标：你想达成团建的什么效果？默契还是文化？ 第四问，关乎手段：活动方案和你的目标匹配吗？ ","date":"2022-04-22","objectID":"/gk-tmp-team-building/:9:0","tags":["Management","Note","Geek"],"title":"[笔记]技术管理实战 36 讲：团队建设篇（管理三部曲之二）","uri":"/gk-tmp-team-building/"},{"categories":["Network"],"content":"本文主要对 tcpdump 做了些简单介绍，以及一些实践经验。 ","date":"2022-02-22","objectID":"/network-tcpdump-try/:0:0","tags":["Network"],"title":"tcpdump 小试","uri":"/network-tcpdump-try/"},{"categories":["Network"],"content":"1. 什么是 tcpdupm tcpdump：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。 ","date":"2022-02-22","objectID":"/network-tcpdump-try/:1:0","tags":["Network"],"title":"tcpdump 小试","uri":"/network-tcpdump-try/"},{"categories":["Network"],"content":"2. 安装 tcpdump yum install -y tcpdump ","date":"2022-02-22","objectID":"/network-tcpdump-try/:2:0","tags":["Network"],"title":"tcpdump 小试","uri":"/network-tcpdump-try/"},{"categories":["Network"],"content":"3. 命令参数简介 普通情况下，直接启动 tcpdump 将监视第一个网络接口上所有流过的数据包。 tcpdump 数字的方式显示 IP 和端口。一个 n 是 ip。如果不指定 –n，下图标红的地方展示的是 hostname：VMS2445。 tcpdump --n tcpdump --n 测试tcpdump \u0026ndash;n 测试 \" tcpdump --n 测试 监视指定网络接口的数据包。如果不指定网卡，默认 tcpdump 只会监视第一个网络接口，一般是 eth0。 tcpdump -i eth1 截获所有 210.27.48.1 的主机收到的和发出的所有的数据包 tcpdump host 210.27.48.1 截获所有发送到机器 210.27.48.1 10000 端口的包 tcpdump -nn -i eth1 dst host 210.27.48.1 and port 10000 ","date":"2022-02-22","objectID":"/network-tcpdump-try/:3:0","tags":["Network"],"title":"tcpdump 小试","uri":"/network-tcpdump-try/"},{"categories":["Network"],"content":"4. ovs 模式下 eth 主备 ovs-appctl bond/show ovs 模式下 eth 主备ovs 模式下 eth 主备 \" ovs 模式下 eth 主备 ","date":"2022-02-22","objectID":"/network-tcpdump-try/:4:0","tags":["Network"],"title":"tcpdump 小试","uri":"/network-tcpdump-try/"},{"categories":["Network"],"content":"5. 参考 [1] https://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html. ","date":"2022-02-22","objectID":"/network-tcpdump-try/:5:0","tags":["Network"],"title":"tcpdump 小试","uri":"/network-tcpdump-try/"},{"categories":["Golang"],"content":"本文主要记录了日常开发中关于 Golang 正则的一些尝试。主要包括 \"\" 和 `` 的区别，贪婪模式和非贪婪模式等。 ","date":"2022-02-17","objectID":"/golang-regexp/:0:0","tags":["Golang"],"title":"Golang 正则小试","uri":"/golang-regexp/"},{"categories":["Golang"],"content":"1. \"\" 和 `` 的区别 首先介绍下 \"\" 和 `` 的区别，因为在后文中会用到相关知识。 \"\" 就是正常的字符串，但是会做字符串转义。 package main import \"fmt\" func main() { str := \"hello world\\n\\nxlxiao\" fmt.Println(str) } 输出如下： 双引号输出结果双引号输出结果 \" 双引号输出结果 `` 原始字符串，不会做字符串转义。 package main import \"fmt\" func main() { str := `hello world\\n\\nxlxiao` fmt.Println(str) } 输出如下： 反引号输出结果反引号输出结果 \" 反引号输出结果 ","date":"2022-02-17","objectID":"/golang-regexp/:1:0","tags":["Golang"],"title":"Golang 正则小试","uri":"/golang-regexp/"},{"categories":["Golang"],"content":"2. 一个小需求引发的案例 通过正则匹配出仓库 “git@github.com:lesliexlxiao/game-of-life.git” 中 lesliexlxiao。 几种正则对比： // 可以匹配成功，但是 . 表示匹配任意一个字符，所以 git@github.com:lesliexlxiao/game-of-lifeagit 也能匹配成功。 regexp.Compile(\"github.com:(.*)/.*.git\") // 报错，unknown escape sequence，在双引号中 \\ 需要转义 regexp.Compile(\"github.com:(.*)/.*\\.git\") // 修复上述 case，可以正确匹配 regexp.Compile(\"github.com:(.*)/.*\\\\.git\") // 可以正确匹配，`` 是原始字符串，\\ 不需要转义，具体原因可以参照 1 regexp.Compile(`github.com:(.*)/.*\\.git`) // 不能正确匹配，只可以匹配 \"git@github.com:lesliexlxiao/game-of-life\\\\.git\" regexp.Compile(`github.com:(.*)/.*\\\\.git`) 所以最后的最优解如下： package main import ( \"fmt\" \"regexp\" ) func main() { repo := \"git@github.com:lesliexlxiao/game-of-life.git\" reg := regexp.MustCompile(`git@github.com:(.*)/.*\\.git`) matches := reg.FindStringSubmatch(repo) if len(matches) \u003e= 2 { fmt.Println(matches[1]) } } 输出如下： 需求输出结果需求输出结果 \" 需求输出结果 ","date":"2022-02-17","objectID":"/golang-regexp/:2:0","tags":["Golang"],"title":"Golang 正则小试","uri":"/golang-regexp/"},{"categories":["Golang"],"content":"3. 贪婪模式和非贪婪模式 为什么会引出贪婪模式和非贪婪模式？因为用到了 reg.FindString，但是 golang 基础库里面还有函数 reg.FindAllString。 对比之后发现 reg.FindString，但是 reg.FindString 为非贪婪模式，而 reg.FindAllString 为贪婪模式。 那么什么是贪婪模式和非贪婪模式？ 非贪婪模式：在整个表达式匹配成功的前提下，尽可能少的匹配。 贪婪模式：在整个表达式匹配成功的前提下，尽可能多的匹配。 验证 reg.FindString： package main import ( \"fmt\" \"regexp\" ) func main() { repo := \"paranormal\" reg := regexp.MustCompile(`a.`) matches := reg.FindString(repo) fmt.Println(matches) } FindString 输出结果FindString 输出结果 \" FindString 输出结果 从上述结果可以看出，只匹配出 ar，做到了尽可能少的匹配。 验证 reg.FindAllString： package main import ( \"fmt\" \"regexp\" ) func main() { repo := \"paranormal\" reg := regexp.MustCompile(`a.`) matches := reg.FindAllString(repo, -1) fmt.Println(matches) } FindAllString 输出结果FindAllString 输出结果 \" FindAllString 输出结果 从上述结果可以看出，匹配出了 [ar an al]，做到了尽可能多的匹配。 ","date":"2022-02-17","objectID":"/golang-regexp/:3:0","tags":["Golang"],"title":"Golang 正则小试","uri":"/golang-regexp/"},{"categories":["Golang"],"content":"4. 参考文献 [1] http://www.9lyp.com/article/info/details/id/70. [2] https://www.cnblogs.com/admans/p/11955614.html. ","date":"2022-02-17","objectID":"/golang-regexp/:4:0","tags":["Golang"],"title":"Golang 正则小试","uri":"/golang-regexp/"},{"categories":["SRE"],"content":"本文主要是看了携程集团商旅事业部的 CTO 宋涛在极客时间上《搭建可靠性系统工程实践》的分享而做的一些笔记及总结。 ","date":"2022-02-16","objectID":"/sre-reliability-systems-engineering-practice/:0:0","tags":["SRE","Note","Geek"],"title":"[笔记]搭建可靠性系统工程实践","uri":"/sre-reliability-systems-engineering-practice/"},{"categories":["SRE"],"content":"1. 可靠性：互联网时代的挑战 关于系统可靠性，业界常用 3 个 9、4 个 9，来计算每年的服务故障时间，从而去衡量系统的可靠性。怎么计算的？ 3 个 9：(1 - 99.9%) * 365 * 24 = 8.76 小时，表示该系统在连续运行 1 年时间里最多可能的业务中断时间是 8.76 小时。 4 个 9：(1 - 99.99%) * 365 * 24 = 0.876 小时 = 52.6 分钟，表示该系统在连续运行 1 年时间里最多可能的业务中断时间是 52.6 分钟。 一般头部互联网公司对他们的关键服务，通常提出的承诺是 4 个 9，也就是每年最多故障 53 分钟。 出现系统故障，亚马逊是以自己常用的 6 页纸的复盘文档形式展现给大家，个人觉得这是一种比较好的方式。通过 6 页纸，你能知道是什么原因触发了什么系统故障，它的影响为什么会进一步放大，整个技术团队做了什么去控制影响。 亚马逊某次故障总结：https://aws.amazon.com/message/11201/ ","date":"2022-02-16","objectID":"/sre-reliability-systems-engineering-practice/:1:0","tags":["SRE","Note","Geek"],"title":"[笔记]搭建可靠性系统工程实践","uri":"/sre-reliability-systems-engineering-practice/"},{"categories":["SRE"],"content":"2. CNCF 带来的改变 CNCF：全称 Cloud Native Computing Foundation（云原生计算基金会）。 ","date":"2022-02-16","objectID":"/sre-reliability-systems-engineering-practice/:2:0","tags":["SRE","Note","Geek"],"title":"[笔记]搭建可靠性系统工程实践","uri":"/sre-reliability-systems-engineering-practice/"},{"categories":["SRE"],"content":"3. 影响可靠性的因素 影响半径或者爆炸半径（Blast Radius）：指的是 Bug、事故能让多少系统停止服务。 ROI：投资回报率。 ","date":"2022-02-16","objectID":"/sre-reliability-systems-engineering-practice/:3:0","tags":["SRE","Note","Geek"],"title":"[笔记]搭建可靠性系统工程实践","uri":"/sre-reliability-systems-engineering-practice/"},{"categories":["SRE"],"content":"4. 不同公司的做法 Code Review Design Review：设计评审 OPS Review SOP：操作规范 ","date":"2022-02-16","objectID":"/sre-reliability-systems-engineering-practice/:4:0","tags":["SRE","Note","Geek"],"title":"[笔记]搭建可靠性系统工程实践","uri":"/sre-reliability-systems-engineering-practice/"},{"categories":["SRE"],"content":"5. 故障分享 War Room：通常指某个事件升级了，大家需要进入一个 War Room 的事件升级状态。War Room 是一些互联网公司在处理大型事故当中总结出来比较有效的方式，就是当大规模事件发生的时候，会把一些骨干技术负责人集中在一间房子里，大家再指挥下边一批人去工作。这种情况下，会有一个人负责对更高一层的人做沟通和决策，整体来说大家各司其职，比较有效率。 ","date":"2022-02-16","objectID":"/sre-reliability-systems-engineering-practice/:5:0","tags":["SRE","Note","Geek"],"title":"[笔记]搭建可靠性系统工程实践","uri":"/sre-reliability-systems-engineering-practice/"},{"categories":["SRE"],"content":"6. 携程商旅实践 “Quality is not an act，it is a habit”，质量都是日常习惯所产生的后果。 Design for failure，需要对我们的 Design 模板明确要求加哪些监控，怎么去报警，系统失败了怎么办？ 对事故复盘有非常详细的 COE 记载，COE 就是复盘报告，包括整个故障的时间、花了多久解决、代码有哪些缺陷是可以共享的。 几类监控 生产维度的数据监控 系统数据监控 关键系统增加流量、成功率以及延时这种 SRE 黄金三元素的监控 在流程或者功能上基于现象的监控，只要出现了问题，没有及时监控，就要补充监控 ","date":"2022-02-16","objectID":"/sre-reliability-systems-engineering-practice/:6:0","tags":["SRE","Note","Geek"],"title":"[笔记]搭建可靠性系统工程实践","uri":"/sre-reliability-systems-engineering-practice/"},{"categories":["SRE"],"content":"7. 参考文档 [1] https://time.geekbang.org/column/article/329756. ","date":"2022-02-16","objectID":"/sre-reliability-systems-engineering-practice/:7:0","tags":["SRE","Note","Geek"],"title":"[笔记]搭建可靠性系统工程实践","uri":"/sre-reliability-systems-engineering-practice/"},{"categories":["Golang"],"content":"本文主要介绍了 golang 语言开发中的一些规范。 ","date":"2020-07-11","objectID":"/golang-style-rules/:0:0","tags":["Golang"],"title":"Golang 开发规范","uri":"/golang-style-rules/"},{"categories":["Golang"],"content":"1. 声明语句的规范化 我们在编写 golang 程序的时候，通常涉及到的内容声明语句包括 package、import、func、var、const、type 等。**import 声明是必须跟在文件的 package 声明之后的，**而 func、var、const、type 等声明语句的顺序并不重要，但我们最好还是定一下规范，这样有助于统一代码风格、提高代码的可读性。个人的内容声明语句风格如下： package main import \"fmt\" type Person struct { name string } const constant string = \"constant\" var v string = \"var\" func main() { p := Person{name: \"xlxiao\"} fmt.Println(p.name) fmt.Println(constant) fmt.Println(v) } ","date":"2020-07-11","objectID":"/golang-style-rules/:1:0","tags":["Golang"],"title":"Golang 开发规范","uri":"/golang-style-rules/"},{"categories":["Golang"],"content":"2. go fmt 的使用 单个文件格式化 $ go fmt hello.go 目录代码格式化 $ go fmt ./directory/ 上述命令只能格式化 directory 目录下的 go 文件，并不能格式化整个项目的 go 文件。 项目格式化，如果项目的 module 名字为 github.com/lesliexlxiao/golang-test，那么格式化语句如下： $ go fmt github.com/lesliexlxiao/golang-test/... ","date":"2020-07-11","objectID":"/golang-style-rules/:2:0","tags":["Golang"],"title":"Golang 开发规范","uri":"/golang-style-rules/"},{"categories":["Golang"],"content":"3. 参考文章 [1] Alan A.A.Donovan, Brian W.Kernighan.Go 语言圣经.p20. [2] My_Fuzz.Golang 编码规范.https://www.jianshu.com/p/1f0ded986f28. ","date":"2020-07-11","objectID":"/golang-style-rules/:3:0","tags":["Golang"],"title":"Golang 开发规范","uri":"/golang-style-rules/"},{"categories":["Python"],"content":"本文主要介绍了 Python 开发当中如何处理 CSV 文件。由于平时开发中经常会使用到相关知识，故作小记以备不时之需。 ","date":"2020-06-21","objectID":"/python-csv/:0:0","tags":["Python"],"title":"Python 中如何处理 CSV 文件","uri":"/python-csv/"},{"categories":["Python"],"content":"1. 参数说明 delimiter：分隔符，默认值 ‘,'。 quotechar：如果某个 item 中包含了分隔符，应该用 quotechar 把它包裹起来。 doublequote：如果某个 item 中出现了 quotechar 那么可以把整个内容用 quotechar 包裹，并把 quotechar double 一下用来做区分。 escapechar：如果不用 doublequote 的方法还可以用 escapechar 来辅助。 lineterminator：每一行的结束符，默认的是 \\r\\n。 quoting：可以选择任何时候都使用 quotechar 来包裹内容，或者是需要用到的时候再用，或者不用。 skipinitialspace：否忽略分隔符后面跟着的空格。 ","date":"2020-06-21","objectID":"/python-csv/:1:0","tags":["Python"],"title":"Python 中如何处理 CSV 文件","uri":"/python-csv/"},{"categories":["Python"],"content":"2. 读取 csv 文件 ","date":"2020-06-21","objectID":"/python-csv/:2:0","tags":["Python"],"title":"Python 中如何处理 CSV 文件","uri":"/python-csv/"},{"categories":["Python"],"content":"示例 1 import csv with open('xlxiao-data.csv') as csv_file: reader = csv.reader(csv_file) for row in reader: print row 注意：这里使用的是 csv.reader， row 是 list 类型。 ","date":"2020-06-21","objectID":"/python-csv/:2:1","tags":["Python"],"title":"Python 中如何处理 CSV 文件","uri":"/python-csv/"},{"categories":["Python"],"content":"示例 2 import csv with open('xlxiao-data.csv') as csv_file: reader = csv.DictReader(csv_file) for row in reader: print row['name'], row['age'] 注意： 这里使用的是 csv.DictReader， row 是 dict 类型。 使用 csv.DictReader 读取的文件必须包含 header。 ","date":"2020-06-21","objectID":"/python-csv/:2:2","tags":["Python"],"title":"Python 中如何处理 CSV 文件","uri":"/python-csv/"},{"categories":["Python"],"content":"3. 写入 csv 文件 ","date":"2020-06-21","objectID":"/python-csv/:3:0","tags":["Python"],"title":"Python 中如何处理 CSV 文件","uri":"/python-csv/"},{"categories":["Python"],"content":"示例 1 import csv with open('xlxiao-data.csv', 'w') as csv_file: writer = csv.writer(csv_file) writer.writerow(['xlxiao', '20']) ","date":"2020-06-21","objectID":"/python-csv/:3:1","tags":["Python"],"title":"Python 中如何处理 CSV 文件","uri":"/python-csv/"},{"categories":["Python"],"content":"示例 2 import csv with open('xlxiao-data.csv', 'w') as csv_file: fieldnames = ['name', 'age'] writer = csv.DictWriter(csv_file, fieldnames=fieldnames) writer.writeheader() writer.writerow({'name': 'xlxiao', 'age': 20}) ","date":"2020-06-21","objectID":"/python-csv/:3:2","tags":["Python"],"title":"Python 中如何处理 CSV 文件","uri":"/python-csv/"},{"categories":["Python"],"content":"4. 如何解决中文乱码问题 ","date":"2020-06-21","objectID":"/python-csv/:4:0","tags":["Python"],"title":"Python 中如何处理 CSV 文件","uri":"/python-csv/"},{"categories":["Python"],"content":"示例 import csv import codecs with open('xlxiao-data.csv', 'w') as csv_file: csv_file.write(codecs.BOM_UTF8) writer = csv.writer(csv_file) writer.writerow(['xlxiao', '20']) 对文件进行 UTF8 编码，即可解决中文编码问题。 ","date":"2020-06-21","objectID":"/python-csv/:4:1","tags":["Python"],"title":"Python 中如何处理 CSV 文件","uri":"/python-csv/"},{"categories":["Python"],"content":"5. 参考文档 [1] https://docs.python.org/3/library/csv.html#id3. [2] https://www.jianshu.com/p/0b0337df165a. ","date":"2020-06-21","objectID":"/python-csv/:5:0","tags":["Python"],"title":"Python 中如何处理 CSV 文件","uri":"/python-csv/"},{"categories":["SCM"],"content":"本文主要介绍了 Maven 依赖相关的一些最佳实践，用来避免和处理很多常见的问题。 ","date":"2020-04-17","objectID":"/scm-maven-dependency-best-practice/:0:0","tags":["SCM","Maven"],"title":"[笔记]Maven 项目依赖最佳实践","uri":"/scm-maven-dependency-best-practice/"},{"categories":["SCM"],"content":"1. 排除依赖 传递性依赖会给项目隐式地引入很多依赖，极大地简化了项目依赖的管理，但是这种特性也会带来问题。这种情况下，可以通过排除依赖来解决问题，下面列举两种情况： 情况一：项目 A 有一个依赖，而这个依赖又依赖了另一个类库的 SNAPSHOT 版本，那么这个 SNAPSHOT 就会成为项目 A 的传递性依赖，SNAPSHOT 的不稳定性会直接影响到项目。这时需要排除掉 SNAPSHOT，并且在当前项目中声明该类库的正式发布版本。 情况二：项目 A 依赖于 Hibernate，而 Hibernate 依赖于 Sun JTA API，但是由于版权因素，Sun JTA API 不在中央仓库中，而 Apache Geronimo 项目中有一个对应的实现。这时可以排除 Sun JTA API 依赖，再声明 Geronimo 中 JTA API 实现。 下面是一个排除依赖的示例： \u003cproject\u003e \u003cmodel\u003e4.0.0\u003c/model\u003e \u003cgroupId\u003ecom.juvenxu.mvnbook\u003c/groupId\u003e \u003cartifactId\u003eproject-a\u003c/artifactId\u003e \u003cversion\u003e1.0.0\u003c/version\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.juvenxu.mvnbook\u003c/groupId\u003e \u003cartifactId\u003eproject-b\u003c/artifactId\u003e \u003cversion\u003e1.0.0\u003c/version\u003e \u003cexclusions\u003e \u003cexclusion\u003e \u003cgroupId\u003ecom.juvenxu.mvbook\u003c/groupId\u003e \u003cartifactId\u003eproject-c\u003c/artifactId\u003e \u003c/exclusion\u003e \u003c/exclusions\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.juvenxu.mvbook\u003c/groupId\u003e \u003cartifactId\u003eproject-c\u003c/artifactId\u003e \u003cversion\u003e1.0.0\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 注意：声明 exclusion 的时候只需要 groupId 和 artifactId，而不需要 version 元素，这时因为只需要 groupId 和 artifactId 就能唯一定位依赖图中的某个依赖。 ","date":"2020-04-17","objectID":"/scm-maven-dependency-best-practice/:1:0","tags":["SCM","Maven"],"title":"[笔记]Maven 项目依赖最佳实践","uri":"/scm-maven-dependency-best-practice/"},{"categories":["SCM"],"content":"2. 归类依赖 所谓的归类依赖，就是把具有相同值的依赖属性抽象出来，方便后期的升级和维护。 下面是以个归类依赖的示例： \u003cproject\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003ecom.juven.mvnbook.account\u003c/groupId\u003e \u003cartifactId\u003eaccount-email\u003c/artifactId\u003e \u003cname\u003eAccount Email\u003c/name\u003e \u003cversion\u003e1.0.0-SNAPSHOT\u003c/version\u003e \u003cproperties\u003e \u003cspringframework.version\u003e2.5.6\u003c/springframework.version\u003e \u003c/properties\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-core\u003c/artifactId\u003e \u003cversion\u003e${springframework.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-beans\u003c/artifactId\u003e \u003cversion\u003e${springframework.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-context-support\u003c/artifactId\u003e \u003cversion\u003e${springframework.version}\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 这里使用 properties 元素来定义 Maven 属性。上述示例中定义 springframework.version 属性值为 2.5.6 。有了这个属性之后，Maven 运行的时候会将 POM 中的所有的 ${springframework.version} 替换为实际值 2.5.6。 ","date":"2020-04-17","objectID":"/scm-maven-dependency-best-practice/:2:0","tags":["SCM","Maven"],"title":"[笔记]Maven 项目依赖最佳实践","uri":"/scm-maven-dependency-best-practice/"},{"categories":["SCM"],"content":"3. 优化依赖 在构建 Maven 项目时，我们应该对 Maven 项目的依赖了然于胸，并对其进行优化，如去除多余的依赖，显示地声明某些必要的依赖。 Maven 能够自动解析所有项目的直接依赖和传递性依赖，解决依赖冲突，最后得到那些依赖的已解析依赖（Resolved Dependencies）。可以通过如下命令查看当前项目的已解析依赖： $ mvn dependency:list 下图展示了所有 account-email 的已解析依赖，同时，每个依赖的范围也得以明确标示： account-email 的已解析依赖account-email 的已解析依赖 \" account-email 的已解析依赖 依赖经过 Maven 解析后，会构成一个依赖树，通过依赖树能够很清楚地看到某个依赖是通过哪条路径引入的。可以通过如下命令查看当前项目的依赖树： $ mvn dependency:tree 下图展示了 account-email 项目的依赖树： account-email 项目的依赖树account-email 项目的依赖树 \" account-email 项目的依赖树 使用 dependency:list 和 dependency:tree 可以帮助我们详细了解项目中所有依赖的具体信息。在此基础上使用 dependency:analyze 工具可以帮助分析当前项目的依赖，从而优化项目依赖。 去除 spring-context 依赖，对 account-email 项目执行如下命令： $ mvn dependency:analyze 结果如下图所示： maven 依赖分析maven 依赖分析 \" maven 依赖分析 Used undeclared dependencies，指项目中使用到的，但是没有显式声明的依赖，这里是 spring-context。通过上面 dependency:tree 的结果可以看出，spring-context 是通过 spring-context-support 依赖传递进来的。当升级 spring-context-support 这种直接依赖时，相关传递性依赖如 spring-context 的版本也可能发生变化，这种变化不易察觉，但是有可能导致当前项目报错。例如由于接口的改变，当前项目中的相关代码无法编译。这种隐藏的、潜在的威胁一旦出现，往往需要耗费大量的时间来查明真相。因此，显式声明任何项目中直接用到的依赖。 Unused declared dependencies，指项目中未使用的，但是显式声明的依赖，这里有 spring-beans。对于这样一类依赖，我们不应该简单地直接删除其声明，而是应该仔细分析。由于 dependency:analyze 只会分析编译主代码和测试代码用到的依赖，一些执行测试和运行时需要的依赖它就发现不了。很显然，该例中 spring-beats 是运行 Spring Framework 项目必要的类库，因此不应该删除依赖声明。 ","date":"2020-04-17","objectID":"/scm-maven-dependency-best-practice/:3:0","tags":["SCM","Maven"],"title":"[笔记]Maven 项目依赖最佳实践","uri":"/scm-maven-dependency-best-practice/"},{"categories":["SCM"],"content":"4. 参考文献 [1] 许晓斌.Maven 实战[M].北京:机械工业出版社,2010:68-74. ","date":"2020-04-17","objectID":"/scm-maven-dependency-best-practice/:4:0","tags":["SCM","Maven"],"title":"[笔记]Maven 项目依赖最佳实践","uri":"/scm-maven-dependency-best-practice/"},{"categories":["SCM"],"content":"本文主要介绍了 Maven 项目依赖的配置、依赖范围、传递性依赖范围、依赖调解和可选依赖相关内容。 ","date":"2020-04-16","objectID":"/scm-maven-dependency-relative/:0:0","tags":["SCM","Maven"],"title":"[笔记]Maven 项目依赖介绍","uri":"/scm-maven-dependency-relative/"},{"categories":["SCM"],"content":"1. 依赖的配置 一个依赖声明可以包含如下元素 \u003cproject\u003e ... \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003e...\u003c/groupId\u003e \u003cartifactId\u003e...\u003c/artifactId\u003e \u003cversion\u003e...\u003c/version\u003e \u003ctype\u003e...\u003c/type\u003e \u003cscope\u003e...\u003c/scope\u003e \u003coptional\u003e...\u003c/optional\u003e \u003cexclusions\u003e \u003cexclusion\u003e ... \u003c/exclusion\u003e ... \u003c/exclusions\u003e \u003c/dependency\u003e ... \u003c/dependencies\u003e ... \u003c/project\u003e type：依赖的类型，对应于项目坐标定义的 packaging。 scope：依赖的范围。 optional：标记依赖是否可选。 exclusions：用来排除传递性依赖。 ","date":"2020-04-16","objectID":"/scm-maven-dependency-relative/:1:0","tags":["SCM","Maven"],"title":"[笔记]Maven 项目依赖介绍","uri":"/scm-maven-dependency-relative/"},{"categories":["SCM"],"content":"2. 依赖范围 Maven 相关的三种 classpath：编译 classpath、测试 classpath、运行 classpath。 Maven 在编译项目主代码的时候，用到的文件以依赖方式被引入到编译 classpath 中。 Maven 在编译和执行测试的时候，用到的文件以依赖方式被引入到测试 classpath 中。 实际运行 Maven 项目的时候，用到的文件以依赖方式被引入到运行 classpath 中。 Maven 有以下几种依赖范围： compile：编译依赖范围。如果没有指定，就会默认使用该依赖范围。 test：测试依赖范围。 provided：已提供依赖范围。 runtime：运行时依赖范围。 system：系统依赖范围。该依赖范围与三种 classpath 的关系，和 provided 依赖范围是一样的。但是，使用该范围的依赖时必须通过 systemPath 元素显式地指定依赖文件的路径。 此类依赖不是通过 Maven 仓库解析的，往往与本机系统绑定，可能造成构建的不可移植，因此应该慎用。例子如下： \u003cdependency\u003e \u003cgroupId\u003ejavax.sql\u003c/groupId\u003e \u003cartifactId\u003ejdbc-stdext\u003c/artifactId\u003e \u003cversion\u003e2.0\u003c/version\u003e \u003cscope\u003esystem\u003c/scope\u003e \u003csystemPath\u003e${java.home}/lib/rt.jar\u003c/systemPath\u003e \u003c/dependency\u003e 下表展示了依赖范围与三种 classpath 的关系： 依赖范围（scope） 对于编译 classpath 有效 对于测试 classpath 有效 对于运行时 classpath 有效 例 子 compile Y Y Y spring-core test — Y — Junit provided Y Y — servlet-api runtime — Y Y JDBC 驱动实现 system Y Y — 本地的，Maven 仓库之外的类库 ","date":"2020-04-16","objectID":"/scm-maven-dependency-relative/:2:0","tags":["SCM","Maven"],"title":"[笔记]Maven 项目依赖介绍","uri":"/scm-maven-dependency-relative/"},{"categories":["SCM"],"content":"3. 传递性依赖 ","date":"2020-04-16","objectID":"/scm-maven-dependency-relative/:3:0","tags":["SCM","Maven"],"title":"[笔记]Maven 项目依赖介绍","uri":"/scm-maven-dependency-relative/"},{"categories":["SCM"],"content":"3.1 何为传递性依赖 假设我们的应用为 account-email，它有一个 spring-core 依赖，而 spring-core 有一个 commons-logging 依赖，那么 commons-logging 是 account-email 的一个传递性依赖。 传递性依赖传递性依赖 \" 传递性依赖 ","date":"2020-04-16","objectID":"/scm-maven-dependency-relative/:3:1","tags":["SCM","Maven"],"title":"[笔记]Maven 项目依赖介绍","uri":"/scm-maven-dependency-relative/"},{"categories":["SCM"],"content":"3.2 传递性依赖范围 下表最左边一列表示第一直接依赖范围，最上面一行表示第二直接依赖范围，中间交叉单元格表示传递性依赖范围。 compile test provided runtime compile compile — — runtime test test — — test provided provided — provided provided runtime runtime — — runtime 可以通过一个例子来理解上面这个表格。account-email 有一个 spring-core 的直接依赖，我们说这是第一直接依赖，其依赖范围是 compile；spring-core 又有一个 commons-logging 的直接依赖，我们说这是第二直接依赖，其依赖范围是 compile。那么 commons-logging 是 ccount-email 的传递性依赖，对照上表可以知道，第一直接依赖范围是 compile，第二直接依赖范围是 compile 时，传递性依赖范围是 compile。 ","date":"2020-04-16","objectID":"/scm-maven-dependency-relative/:3:2","tags":["SCM","Maven"],"title":"[笔记]Maven 项目依赖介绍","uri":"/scm-maven-dependency-relative/"},{"categories":["SCM"],"content":"4. 依赖调解 依赖调解主要遵循两个规则： 路径最近者优先。比如 A-\u003eB-\u003eC-\u003eX(1.0)，A-\u003eD-\u003eX(2.0)，那么此时 X(2.0) 会被解析使用。 第一声明者优先。比如 A-\u003eB-\u003eY(1.0)，A-\u003eB-\u003eY(1.0)，因为两条依赖路径的长度是一样的，那么就得遵循第一声明者优先原则。如果 B 声明在 C 之前，那么此时 Y(1.0) 会被解析使用。 ","date":"2020-04-16","objectID":"/scm-maven-dependency-relative/:4:0","tags":["SCM","Maven"],"title":"[笔记]Maven 项目依赖介绍","uri":"/scm-maven-dependency-relative/"},{"categories":["SCM"],"content":"5. 可选依赖 假如有这样一个依赖关系：A-\u003eB、B-\u003eX(可选依赖)、B-\u003eY(可选依赖)，那么 X、Y 将不会对 A 有任何影响，因为可选依赖不会得以传递。 为什么需要可选依赖？可能项目 B 实现了两个特性，其中的特性一依赖于 X，特性二依赖于 Y，而且这两个特性是互斥的，用户不可能同时使用两个特性。如果不设置可选依赖，那么 X、Y 都会被传递给 A，造成冲突。比如 B 是一个持久层隔离工具包，它支持多种数据库，包括 MySQL、PostgreSQL 等，在构建工具包的时候，需要这两种数据库的驱动程序，但在使用这个工具包的时候，只会依赖某种数据库。 项目 B 依赖声明如下： \u003cproject\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003ecom.juvenxu.mvnbook\u003c/groupId\u003e \u003cartifactId\u003eproject-b\u003c/artifactId\u003e \u003cversion\u003e1.0.0\u003c/version\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.0\u003c/version\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003epostgresql\u003c/groupId\u003e \u003cartifactId\u003epostgresql\u003c/artifactId\u003e \u003cversion\u003e8.4-701.jdbc3\u003c/version\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 上述 XML 中 optional 为 true，它们只会对当前项目 B 产生影响。此时由于 mysql、postgresql 依赖都不会被传递个 A，所以当 A 使用 MySQL 数据库时，就需要显式地声明 mysql-connector-java 这一依赖。 在理想情况下，是不应该使用可选依赖的。面向对象设计中，有个单一职责原则，即一个类只有一项职责。所以针对上述例子，更好的做法是为 MySQL 和 PostgreSQL 分别创建一个 Maven 项目。将 B 拆分为两个项目 C 和 D，C 和 D 中声明对应的 JDBC 驱动依赖，那么此时 A 就可以根据需求去选择使用 C 或者 B 依赖。 ","date":"2020-04-16","objectID":"/scm-maven-dependency-relative/:5:0","tags":["SCM","Maven"],"title":"[笔记]Maven 项目依赖介绍","uri":"/scm-maven-dependency-relative/"},{"categories":["SCM"],"content":"6. 参考文献 [1] 许晓斌.Maven 实战[M].北京:机械工业出版社,2010:62-68. ","date":"2020-04-16","objectID":"/scm-maven-dependency-relative/:6:0","tags":["SCM","Maven"],"title":"[笔记]Maven 项目依赖介绍","uri":"/scm-maven-dependency-relative/"},{"categories":["SCM"],"content":"本文主要介绍了 maven pom.xml 中各元素的详细意义。 ","date":"2020-04-13","objectID":"/scm-maven-pom-detail/:0:0","tags":["Maven","SCM"],"title":"Maven pom.xml 文件详解","uri":"/scm-maven-pom-detail/"},{"categories":["SCM"],"content":"1. pom.xml 文件详解 \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003c!-- 声明项目描述符遵循哪一个 POM 模型版本。 模型本身的版本很少改变，虽然如此，但它仍然是必不可少的， 这是为了当 Maven 引入了新的特性或者其他模型变更的时候，确保稳定性。 maven2.0 必须使用如下写法，现在是 maven2.0 唯一支持的版本。 --\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003c!-- 父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 --\u003e \u003cparent\u003e \u003cgroupId\u003ecom.bidu\u003c/groupId\u003e \u003cartifactId\u003esuper-pom\u003c/artifactId\u003e \u003cversion\u003e0.0.1\u003c/version\u003e \u003c!-- 父项目的 pom.xml 文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。 Maven 首先在构建当前项目的地方寻找父项目的 pom，然后在本地仓库，最后在远程仓库寻找父项目的 pom。 RelativePath 允许你选择一个不同的位置。 --\u003e \u003crelativePath\u003exxx\u003c/relativePath\u003e \u003c/parent\u003e \u003c!-- 定义了项目属于哪个组，公司或者组织的唯一标识， 并且构建时生成的路径也是由此生成， 如 com.mycompany.app 生成的相对路径为：/com/mycompany/app --\u003e \u003cgroupId\u003ecom.bidu\u003c/groupId\u003e \u003c!-- 定义了当前 maven 项目在组中的唯一的 ID。 它和 group ID 一起唯一标识一个构件。 --\u003e \u003cartifactId\u003esuper-pom\u003c/artifactId\u003e \u003c!-- 本项目目前所处的版本号 --\u003e \u003cversion\u003e0.0.1\u003c/version\u003e \u003c!-- 项目产生的构件类型，例如 jar、war、ear、pom。 插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型。默认为 jar。 --\u003e \u003cpackaging\u003epom\u003c/packaging\u003e \u003c!-- 项目的名称，Maven 产生的文档用 --\u003e \u003cname\u003eBidu company super pom\u003c/name\u003e \u003c!-- 项目主页的 URL，Maven 产生的文档用 --\u003e \u003curl\u003e http://maven.apache.org \u003c/url\u003e \u003c!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用 HTML 格式描述时（例如，CDATA 中的文本会被解析器忽略，就可以包含HTML标签）， 不鼓励使用纯文本描述。 如果你需要修改产生的 web 站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --\u003e \u003cdescription\u003eBidu 公司 super pom\u003c/description\u003e \u003c!-- 描述项目所属组织的各种属性。Maven 产生的文档用 --\u003e \u003corganization\u003e \u003c!-- 组织的全名 --\u003e \u003cname\u003eBidi\u003c/name\u003e \u003c!-- 组织主页的URL --\u003e \u003curl\u003ehttp://www.bidu.com\u003c/url\u003e \u003c/organization\u003e \u003c!-- 为 pom 定义一些常量，在 pom 中的其它地方可以直接引用， 使用方式如下：${java.version} ，${maven-surefire-plugin.version} --\u003e \u003cproperties\u003e \u003cjava.version\u003e1.7\u003c/java.version\u003e \u003cmaven-surefire-plugin.version\u003e2.19.1\u003c/maven-surefire-plugin.version\u003e \u003cspring.version\u003e4.3.4.RELEASE\u003c/spring.version\u003e \u003c/properties\u003e \u003c!-- 构建项目需要的信息 --\u003e \u003cbuild\u003e \u003c!-- 子项目可以引用的默认插件信息。 该插件配置项直到被引用时才会被解析或绑定到生命周期。 给定插件的任何本地配置都会覆盖这里的配置。 --\u003e \u003cpluginManagement\u003e \u003cplugins\u003e \u003cplugin\u003e \u003c!-- 插件在仓库里的 group ID --\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003c!-- 插件在仓库里的 artifact ID --\u003e \u003cartifactId\u003emaven-enforcer-plugin\u003c/artifactId\u003e \u003c!-- 被使用的插件的版本（或版本范围） --\u003e \u003cversion\u003e${maven-enforcer-plugin_version}\u003c/version\u003e \u003c!-- 是否从该插件下载 Maven 扩展（例如打包和类型处理器）， 由于性能原因，只有在真需要下载时，该元素才被设置成 enabled。 --\u003e \u003cextensions\u003etrue/false\u003c/extensions\u003e \u003c!-- 在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --\u003e \u003cexecutions\u003e \u003cexecution\u003e \u003c!-- 执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --\u003e \u003cid\u003e\u003c/id\u003e \u003c!-- 绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --\u003e \u003cphase\u003e\u003c/phase\u003e \u003c!-- 配置的执行目标 --\u003e \u003cgoals\u003e\u003c/goals\u003e \u003c!-- 配置是否被传播到子POM --\u003e \u003cinherited\u003etrue/false\u003c/inherited\u003e \u003c!-- 作为 DOM 对象的配置 --\u003e \u003cconfiguration\u003e\u003c/configuration\u003e \u003c/execution\u003e \u003c/executions\u003e \u003c!-- 项目引入插件所需要的额外依赖 --\u003e \u003cdependencies\u003e \u003c!-- 参见dependencies/dependency元素 --\u003e \u003cdependency\u003e \u003cgroupId\u003ebidu.scm\u003c/groupId\u003e \u003cartifactId\u003eenforcer-custom-rules\u003c/artifactId\u003e \u003cversion\u003e${enforcer-custom-rules_version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.codehaus.mojo\u003c/groupId\u003e \u003cartifactId\u003eextra-enforcer-rules\u003c/artifactId\u003e \u003cversion\u003e${extra-enforcer-rules_version}\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c!-- 任何配置是否被传播到子项目 --\u003e \u003cinherited\u003etrue/false\u003c/inherited\u003e \u003c!-- 作为 DOM 对象的配置 --\u003e \u003cconfiguration\u003e\u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/pluginManagement\u003e \u003c!-- 该项目使用的插件列表 --\u003e \u003cplugins\u003e \u003cplugin\u003e \u003c!-- 插件在仓库里的 group ID --\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003c!-- 插件在仓库里的 artifact ID --\u003e \u003cartifactId\u003emaven-enforcer-plugin\u003c/artifactId\u003e \u003c!-- 被使用的插件的版本（或版本范围）--\u003e \u003cversion\u003e\u003c/version\u003e \u003c!-- 是否从该插件下载 Maven 扩展（例如打包和类型处理器）， 由于性能原因，只有在真需要下载时，该元素才被设置成 enabled。 --\u003e \u003cextensions\u003etrue/false\u003c/extensions\u003e \u003c!-- 在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --\u003e \u003cexecutions\u003e \u003c!-- execution 元素包含了插件执行需要的信息 --\u003e \u003cexecution\u003e \u003c!-- 执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --\u003e \u003cid\u003ebidu-check\u003c/id\u003e \u003c!-- 绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --\u003e \u003cphase\u003evalidate\u003c/phase\u003e \u003c!-- 配置的执行目标 --\u003e \u003cgoals\u003e \u003cgoal\u003eenforce\u003c/goal\u003e \u003c/goals\u003e \u003c!-- 配置是否被传播到子 POM --\u003e \u003cinherited\u003etrue/false\u003c/inherited\u003e \u003c!-- 作为 DOM 对象的配置 --\u003e \u003cconfiguration\u003e\u003c/configuration\u003e ","date":"2020-04-13","objectID":"/scm-maven-pom-detail/:1:0","tags":["Maven","SCM"],"title":"Maven pom.xml 文件详解","uri":"/scm-maven-pom-detail/"},{"categories":["SCM"],"content":"2. 插件参考文档 文档地址：https://maven.apache.org/plugins/. ","date":"2020-04-13","objectID":"/scm-maven-pom-detail/:2:0","tags":["Maven","SCM"],"title":"Maven pom.xml 文件详解","uri":"/scm-maven-pom-detail/"},{"categories":["SCM"],"content":"3. 参考文献 [1] 史上最全的 maven 的 pom.xml 文件详解. [2] Maven 之 pom.xml 配置文件详解. ","date":"2020-04-13","objectID":"/scm-maven-pom-detail/:3:0","tags":["Maven","SCM"],"title":"Maven pom.xml 文件详解","uri":"/scm-maven-pom-detail/"},{"categories":["Algorithm"],"content":"1. 题目描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 ","date":"2019-05-25","objectID":"/algorithm-two-sum/:1:0","tags":["Algorithm"],"title":"两数之和","uri":"/algorithm-two-sum/"},{"categories":["Algorithm"],"content":"2. 示例 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] ","date":"2019-05-25","objectID":"/algorithm-two-sum/:2:0","tags":["Algorithm"],"title":"两数之和","uri":"/algorithm-two-sum/"},{"categories":["Algorithm"],"content":"3. 解法 ","date":"2019-05-25","objectID":"/algorithm-two-sum/:3:0","tags":["Algorithm"],"title":"两数之和","uri":"/algorithm-two-sum/"},{"categories":["Algorithm"],"content":"3.1 暴力解法 func TwoSum(nums []int, target int) []int { var ret []int for index1, num1 := range nums { for index2, num2 := range nums { if index1 != index2 \u0026\u0026 num1 + num2 == target { ret = []int{index1, index2} break } } if ret != nil { break } } return ret } 时间复杂度：O(n^2) 空间复杂度：O(1) ","date":"2019-05-25","objectID":"/algorithm-two-sum/:3:1","tags":["Algorithm"],"title":"两数之和","uri":"/algorithm-two-sum/"},{"categories":["Algorithm"],"content":"3.2 一遍哈希表 func TwoSum(nums []int, target int) []int { var ret []int numsMap := make(map[int]int) for index, num := range nums { subductionNum := target - num if _, ok := numsMap[subductionNum]; ok { ret = []int{numsMap[subductionNum], index} } else { numsMap[num] = index } } return ret } 时间复杂度：O(n) 空间复杂度：O(n) ","date":"2019-05-25","objectID":"/algorithm-two-sum/:3:2","tags":["Algorithm"],"title":"两数之和","uri":"/algorithm-two-sum/"},{"categories":["Algorithm"],"content":"4. 来源 LeetCode：https://leetcode-cn.com/problems/two-sum ","date":"2019-05-25","objectID":"/algorithm-two-sum/:4:0","tags":["Algorithm"],"title":"两数之和","uri":"/algorithm-two-sum/"},{"categories":["Algorithm"],"content":"5. 参考文章 [1] https://blazehu.github.io/2020/05/12/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/#more ","date":"2019-05-25","objectID":"/algorithm-two-sum/:5:0","tags":["Algorithm"],"title":"两数之和","uri":"/algorithm-two-sum/"},{"categories":["Algorithm"],"content":"1. 如何事半功倍地学习算法和数据结构 ","date":"2019-03-24","objectID":"/algorithm-summary/:1:0","tags":["Algorithm"],"title":"算法综述","uri":"/algorithm-summary/"},{"categories":["Algorithm"],"content":"1.1 Chunk it up（切碎知识点） 庖丁解牛 脉络连接 ","date":"2019-03-24","objectID":"/algorithm-summary/:1:1","tags":["Algorithm"],"title":"算法综述","uri":"/algorithm-summary/"},{"categories":["Algorithm"],"content":"1.2 Deliberate practing（刻意练习） 刻意练习 练习缺陷、不舒服、弱点地方 ","date":"2019-03-24","objectID":"/algorithm-summary/:1:2","tags":["Algorithm"],"title":"算法综述","uri":"/algorithm-summary/"},{"categories":["Algorithm"],"content":"1.3 Feedback（获得反馈） 即时反馈 主动型反馈（自己去找） 高手代码（Github，LeetCode，etc.） 第一视角直播（一些直播的代码） 被动式反馈（高手给你指点） code review 教练看你打，给你反馈 ","date":"2019-03-24","objectID":"/algorithm-summary/:1:3","tags":["Algorithm"],"title":"算法综述","uri":"/algorithm-summary/"},{"categories":["Algorithm"],"content":"1.4 算法切题四件套 Clarification（明确题目意思） Possible solutions（把所有可能解法都搞出来，对比时间复杂度和空间复杂度，使用最优解） compare（time/space） optimal（加强） Coding（多写） Test cases ","date":"2019-03-24","objectID":"/algorithm-summary/:1:4","tags":["Algorithm"],"title":"算法综述","uri":"/algorithm-summary/"},{"categories":["Algorithm"],"content":"2. 算法复杂度分析 算法复杂度主要分为：时间复杂度和空间复杂度。 ","date":"2019-03-24","objectID":"/algorithm-summary/:2:0","tags":["Algorithm"],"title":"算法综述","uri":"/algorithm-summary/"},{"categories":["Algorithm"],"content":"2.1 常见复杂度表示 O(1)：Constant Complexity: Constant 常数复杂度 O(log n)：Logarithmic Complexity: 对数复杂度 O(n)：Linear Complexity: 线性时间复杂度 O(n^2)：N square Complexity 平⽅ O(n^3)：N square Complexity ⽴⽅ O(2^n)：Exponential Growth 指数 O(n!)：Factorial 阶乘 ","date":"2019-03-24","objectID":"/algorithm-summary/:2:1","tags":["Algorithm"],"title":"算法综述","uri":"/algorithm-summary/"},{"categories":["Algorithm"],"content":"2.2 示例 O(1) int n = 1000; System.out.println(\"Hey - your input is: \" + n); O(1) int n = 1000; System.out.println(\"Hey - your input is: \" + n); System.out.println(\"Hmm.. I'm doing more stuff with: \" + n); System.out.println(\"And more: \" + n); O(N) for (int = 1; i \u003c= n; i++) { System.out.println(\"Hey - I'm busy looking at: \" + i); } O(N^2) for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= n; j++) { System.out.println(\"Hey - I'm busy looking at: \" + i + \" and \" + j); } } O(log(n)) for (int i = 1; i \u003c n; i = i * 2) { System.out.println(\"Hey - I'm busy looking at: \" + i); } O(k^n) for (int i = 1; i \u003c= Math.pow(2, n); i++){ System.out.println(\"Hey - I'm busy looking at: \" + i); } O(n!) for (int i = 1; i \u003c= factorial(n); i++){ System.out.println(\"Hey - I'm busy looking at: \" + i); } ","date":"2019-03-24","objectID":"/algorithm-summary/:2:2","tags":["Algorithm"],"title":"算法综述","uri":"/algorithm-summary/"},{"categories":["Algorithm"],"content":"2.2 算法复杂度趋势图 算法复杂度趋势算法复杂度趋势 \" 算法复杂度趋势 ","date":"2019-03-24","objectID":"/algorithm-summary/:2:3","tags":["Algorithm"],"title":"算法综述","uri":"/algorithm-summary/"},{"categories":["Algorithm"],"content":"3. 如何通过 LeetCode 来进行算法练习 国外：https://leetcode.com/problemset/all/ 国内：https://leetcode-cn.com/problemset/all/ ","date":"2019-03-24","objectID":"/algorithm-summary/:3:0","tags":["Algorithm"],"title":"算法综述","uri":"/algorithm-summary/"},{"categories":["Python"],"content":"本文主要介绍了 Python 开发中如何搭建虚拟的隔离环境，从而确保各应用之间的依赖互不影响。 ","date":"2019-03-17","objectID":"/python-virtualenv/:0:0","tags":["Python"],"title":"virtualenv and virtualenvwrapper 工具的使用","uri":"/python-virtualenv/"},{"categories":["Python"],"content":"1. 工具简介 virtualenv 用来为一个应用创建一套\"隔离\"的 python 运行环境。 virtualenvwrapper 基于 virtualenv 之上的工具，用来对虚拟环境进行统一管理。 ","date":"2019-03-17","objectID":"/python-virtualenv/:1:0","tags":["Python"],"title":"virtualenv and virtualenvwrapper 工具的使用","uri":"/python-virtualenv/"},{"categories":["Python"],"content":"2. 工具安装 $ pip install virtualenv virtualenvwrapper ","date":"2019-03-17","objectID":"/python-virtualenv/:2:0","tags":["Python"],"title":"virtualenv and virtualenvwrapper 工具的使用","uri":"/python-virtualenv/"},{"categories":["Python"],"content":"3. virtualenv 用法 创建环境（默认创建的环境会使用系统已经安装的包） $ virtualenv venv 创建环境（不使用系统的包） $ virtualenv --no-site-packages venv 激活环境 $ source venv/bin/activate 退出环境 $ deactive ","date":"2019-03-17","objectID":"/python-virtualenv/:3:0","tags":["Python"],"title":"virtualenv and virtualenvwrapper 工具的使用","uri":"/python-virtualenv/"},{"categories":["Python"],"content":"4. virtualenvwrapper 用法 创建目录用来存放虚拟环境 $ mkdir ~/.virtualenvs 在 .bashrc 中添加 $ export WORKON_HOME=~/.virtualenvs $ source /usr/local/bin/virtualenvwrapper.sh 激活 .bashrc $ source ~/.bashrc 新建虚拟环境 $ mkvirtualenv test 列出虚拟环境列表 $ workon $ lsvirtualenv 切换虚拟环境 $ workon test 删除虚拟环境 $ rmvirtualenv test 离开虚拟环境 $ deactivate ","date":"2019-03-17","objectID":"/python-virtualenv/:4:0","tags":["Python"],"title":"virtualenv and virtualenvwrapper 工具的使用","uri":"/python-virtualenv/"},{"categories":["Markdown"],"content":"这篇文章展示了基本的 Markdown 语法和格式。","date":"2019-12-01","objectID":"/basic-markdown-syntax/","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"这篇文章提供了可以在 Hugo 的文章中使用的基本 Markdown 语法示例。 注意 这篇文章借鉴了一篇很棒的 来自 Grav 的文章。 如果你想了解 FixIt 主题的扩展 Markdown 语法，请阅读 扩展 Markdown 语法页面。 事实上，编写 Web 内容很麻烦。WYSIWYG所见即所得 编辑器帮助减轻了这一任务。但通常会导致代码太糟，或更糟糕的是，网页也会很丑。 没有通常伴随的所有复杂和丑陋的问题，Markdown 是一种更好的生成 HTML 内容的方式。 一些主要好处是： Markdown 简单易学，几乎没有多余的字符，因此编写内容也更快。 用 Markdown 书写时出错的机会更少。 可以产生有效的 XHTML 输出。 将内容和视觉显示保持分开，这样就不会打乱网站的外观。 可以在你喜欢的任何文本编辑器或 Markdown 应用程序中编写内容。 Markdown 使用起来很有趣！ John Gruber, Markdown 的作者如是说： Markdown 格式的首要设计目标是更具可读性。 最初的想法是 Markdown 格式的文档应当以纯文本形式发布， 而不会看起来像被标签或格式说明所标记。 虽然 Markdown 的语法受到几种现有的文本到 HTML 转换工具的影响， 但 Markdown 语法的最大灵感来源是纯文本电子邮件的格式。 – John Gruber 话不多说，我们来回顾一下 Markdown 的主要语法以及生成的 HTML 样式！ 技巧  将此页保存为书签，以备将来参考！ ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:0:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"1 标题 从 h2 到 h6 的标题在每个级别上都加上一个 ＃: ## h2 标题 ### h3 标题 #### h4 标题 ##### h5 标题 ###### h6 标题 输出的 HTML 看起来像这样： \u003ch2\u003eh2 标题\u003c/h2\u003e \u003ch3\u003eh3 标题\u003c/h3\u003e \u003ch4\u003eh4 标题\u003c/h4\u003e \u003ch5\u003eh5 标题\u003c/h5\u003e \u003ch6\u003eh6 标题\u003c/h6\u003e 标题 ID 要添加自定义标题 ID, 请在与标题相同的行中将自定义 ID 放在花括号中： ### 一个很棒的标题 {#custom-id} 输出的 HTML 看起来像这样： \u003ch3 id=\"custom-id\"\u003e一个很棒的标题\u003c/h3\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:1:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"2 注释 注释是和 HTML 兼容的： \u003c!-- 这是一段注释 --\u003e 不能看到以下的注释： ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:2:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"3 水平线 HTML 中的 \u003chr\u003e 标签是用来在段落元素之间创建一个 “专题间隔” 的。 使用 Markdown, 你可以用以下方式创建一个 \u003chr\u003e 标签： ___: 三个连续的下划线 ---: 三个连续的破折号 ***: 三个连续的星号 呈现的输出效果如下： ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:3:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"4 段落 按照纯文本的方式书写段落，纯文本在呈现的 HTML 中将用 \u003cp\u003e/\u003c/p\u003e 标签包裹。 如下段落： Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad. 输出的 HTML 看起来像这样： \u003cp\u003eLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.\u003c/p\u003e 可以使用一个空白行进行换行. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:4:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"5 内联 HTML 元素 如果你需要某个 HTML 标签 （带有一个类）, 则可以简单地像这样使用： Markdown 格式的段落。 \u003cdiv class=\"class\"\u003e 这是 \u003cb\u003eHTML\u003c/b\u003e \u003c/div\u003e Markdown 格式的段落。 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:5:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"6 强调 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"加粗 用于强调带有较粗字体的文本片段。 以下文本片段会被 渲染为粗体. **渲染为粗体** __渲染为粗体__ 输出的 HTML 看起来像这样： \u003cstrong\u003e渲染为粗体\u003c/strong\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:1","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"斜体 用于强调带有斜体的文本片段。 以下文本片段被 渲染为斜体。 *渲染为斜体* _渲染为斜体_ 输出的 HTML 看起来像这样： \u003cem\u003e渲染为斜体\u003c/em\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:2","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"删除线 按照 GFMGitHub flavored Markdown 你可以使用删除线。 ~~这段文本带有删除线。~~ 呈现的输出效果如下： 这段文本带有删除线。 输出的 HTML 看起来像这样： \u003cdel\u003e这段文本带有删除线。\u003c/del\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:3","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"组合 加粗，斜体，和删除线可以 组合使用。 ***加粗和斜体*** ~~**删除线和加粗**~~ ~~*删除线和斜体*~~ ~~***加粗，斜体和删除线***~~ 呈现的输出效果如下： 加粗和斜体 删除线和加粗 删除线和斜体 加粗，斜体和删除线 输出的 HTML 看起来像这样： \u003cem\u003e\u003cstrong\u003e加粗和斜体\u003c/strong\u003e\u003c/em\u003e \u003cdel\u003e\u003cstrong\u003e删除线和加粗\u003c/strong\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e删除线和斜体\u003c/em\u003e\u003c/del\u003e \u003cdel\u003e\u003cem\u003e\u003cstrong\u003e加粗，斜体和删除线\u003c/strong\u003e\u003c/em\u003e\u003c/del\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:6:4","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"7 引用 用于在文档中引用其他来源的内容块。 在要引用的任何文本之前添加 \u003e: \u003e **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 呈现的输出效果如下： Fusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. 输出的 HTML 看起来像这样： \u003cblockquote\u003e \u003cp\u003e \u003cstrong\u003eFusion Drive\u003c/strong\u003e combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined. \u003c/p\u003e \u003c/blockquote\u003e 引用也可以嵌套： \u003e Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. \u003e\u003e Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. 呈现的输出效果如下： Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue. Nunc augue augue, aliquam non hendrerit ac, commodo vel nisi. Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor odio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:7:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"8 列表 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"无序列表 一系列项的列表，其中项的顺序没有明显关系。 你可以使用以下任何符号来表示无序列表中的项： * 一项内容 - 一项内容 + 一项内容 例如： * Lorem ipsum dolor sit amet * Consectetur adipiscing elit * Integer molestie lorem at massa * Facilisis in pretium nisl aliquet * Nulla volutpat aliquam velit * Phasellus iaculis neque * Purus sodales ultricies * Vestibulum laoreet porttitor sem * Ac tristique libero volutpat at * Faucibus porta lacus fringilla vel * Aenean sit amet erat nunc * Eget porttitor lorem 呈现的输出效果如下： Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Phasellus iaculis neque Purus sodales ultricies Vestibulum laoreet porttitor sem Ac tristique libero volutpat at Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样： \u003cul\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit \u003cul\u003e \u003cli\u003ePhasellus iaculis neque\u003c/li\u003e \u003cli\u003ePurus sodales ultricies\u003c/li\u003e \u003cli\u003eVestibulum laoreet porttitor sem\u003c/li\u003e \u003cli\u003eAc tristique libero volutpat at\u003c/li\u003e \u003c/ul\u003e \u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ul\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:1","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"有序列表 一系列项的列表，其中项的顺序确实很重要。 1. Lorem ipsum dolor sit amet 2. Consectetur adipiscing elit 3. Integer molestie lorem at massa 4. Facilisis in pretium nisl aliquet 5. Nulla volutpat aliquam velit 6. Faucibus porta lacus fringilla vel 7. Aenean sit amet erat nunc 8. Eget porttitor lorem 呈现的输出效果如下： Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem 输出的 HTML 看起来像这样： \u003col\u003e \u003cli\u003eLorem ipsum dolor sit amet\u003c/li\u003e \u003cli\u003eConsectetur adipiscing elit\u003c/li\u003e \u003cli\u003eInteger molestie lorem at massa\u003c/li\u003e \u003cli\u003eFacilisis in pretium nisl aliquet\u003c/li\u003e \u003cli\u003eNulla volutpat aliquam velit\u003c/li\u003e \u003cli\u003eFaucibus porta lacus fringilla vel\u003c/li\u003e \u003cli\u003eAenean sit amet erat nunc\u003c/li\u003e \u003cli\u003eEget porttitor lorem\u003c/li\u003e \u003c/ol\u003e 技巧 如果你对每一项使用 1., Markdown 将自动为每一项编号。例如： 1. Lorem ipsum dolor sit amet 1. Consectetur adipiscing elit 1. Integer molestie lorem at massa 1. Facilisis in pretium nisl aliquet 1. Nulla volutpat aliquam velit 1. Faucibus porta lacus fringilla vel 1. Aenean sit amet erat nunc 1. Eget porttitor lorem 呈现的输出效果如下： Lorem ipsum dolor sit amet Consectetur adipiscing elit Integer molestie lorem at massa Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit Faucibus porta lacus fringilla vel Aenean sit amet erat nunc Eget porttitor lorem ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:2","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"任务列表 任务列表使你可以创建带有复选框的列表。 要创建任务列表，请在任务列表项之前添加破折号 (-) 和带有空格的方括号 ([ ])，要选择一个复选框，请在方括号之间添加 x ([x])。 - [x] Write the press release - [ ] Update the website - [ ] Contact the media 呈现的输出效果如下： Write the press release Update the website Contact the media ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:8:3","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"9 代码 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"行内代码 用 ` 包装行内代码段。 在这个例子中，`\u003csection\u003e\u003c/section\u003e` 会被包裹成 **代码**。 呈现的输出效果如下： 在这个例子中，\u003csection\u003e\u003c/section\u003e 会被包裹成 代码。 输出的 HTML 看起来像这样： \u003cp\u003e 在这个例子中，\u003ccode\u003e\u0026lt;section\u0026gt;\u0026lt;/section\u0026gt;\u003c/code\u003e 会被包裹成 \u003cstrong\u003e代码\u003c/strong\u003e。 \u003c/p\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:1","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"缩进代码 将几行代码缩进至少四个空格，例如： // Some comments line 1 of code line 2 of code line 3 of code 呈现的输出效果如下： // Some comments line 1 of code line 2 of code line 3 of code 输出的 HTML 看起来像这样： \u003cpre\u003e \u003ccode\u003e // Some comments line 1 of code line 2 of code line 3 of code \u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:2","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"围栏代码块 使用 “围栏” ``` 来生成一段带有语言属性的代码块。 ```markdown Sample text here... ``` 输出的 HTML 看起来像这样： \u003cpre language-html\u003e \u003ccode\u003eSample text here...\u003c/code\u003e \u003c/pre\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:3","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"语法高亮 GFMGitHub Flavored Markdown 也支持语法高亮。 要激活它，只需在第一个代码 “围栏” 之后直接添加你要使用的语言的文件扩展名， ```js, 语法高亮显示将自动应用于渲染的 HTML 中。 例如，在以下 JavaScript 代码中应用语法高亮： ```js grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; ``` 呈现的输出效果如下： grunt.initConfig({ assemble: { options: { assets: 'docs/assets', data: 'src/data/*.{json,yml}', helpers: 'src/custom-helpers.js', partials: ['src/partials/**/*.{hbs,md}'] }, pages: { options: { layout: 'default.hbs' }, files: { './': ['src/templates/pages/index.hbs'] } } } }; 注意 Hugo 文档中的 语法高亮页面 介绍了有关语法高亮的更多信息， 包括语法高亮的 shortcode。 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:9:4","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"10 表格 通过在每个单元格之间添加竖线作为分隔线，并在标题下添加一行破折号 （也由竖线分隔） 来创建表格。注意，竖线不需要垂直对齐。 | Option | Description | | ------ | ----------- | | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下： Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 输出的 HTML 看起来像这样： \u003ctable\u003e \u003cthead\u003e \u003ctr\u003e \u003cth\u003eOption\u003c/th\u003e \u003cth\u003eDescription\u003c/th\u003e \u003c/tr\u003e \u003c/thead\u003e \u003ctbody\u003e \u003ctr\u003e \u003ctd\u003edata\u003c/td\u003e \u003ctd\u003epath to data files to supply the data that will be passed into templates.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eengine\u003c/td\u003e \u003ctd\u003eengine to be used for processing templates. Handlebars is the default.\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003eext\u003c/td\u003e \u003ctd\u003eextension to be used for dest files.\u003c/td\u003e \u003c/tr\u003e \u003c/tbody\u003e \u003c/table\u003e 文本右对齐或居中对齐 在任何标题下方的破折号右侧添加冒号将使该列的文本右对齐。 在任何标题下方的破折号两边添加冒号将使该列的对齐文本居中。 | Option | Description | |:------:| -----------:| | data | path to data files to supply the data that will be passed into templates. | | engine | engine to be used for processing templates. Handlebars is the default. | | ext | extension to be used for dest files. | 呈现的输出效果如下： Option Description data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:10:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"11 链接 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"基本链接 \u003chttps://assemble.io\u003e \u003ccontact@revolunet.com\u003e [Assemble](https://assemble.io) 呈现的输出效果如下 （将鼠标悬停在链接上，没有提示）: https://assemble.io contact@revolunet.com Assemble 输出的 HTML 看起来像这样： \u003ca href=\"https://assemble.io\"\u003ehttps://assemble.io\u003c/a\u003e \u003ca href=\"mailto:contact@revolunet.com\"\u003econtact@revolunet.com\u003c/a\u003e \u003ca href=\"https://assemble.io\"\u003eAssemble\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:1","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"添加一个标题 [Upstage](https://github.com/upstage/ \"Visit Upstage!\") 呈现的输出效果如下 （将鼠标悬停在链接上，会有一行提示）: Upstage 输出的 HTML 看起来像这样： \u003ca href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"\u003eUpstage\u003c/a\u003e ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:2","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"定位标记 定位标记使你可以跳至同一页面上的指定锚点。例如，每个章节： ## Table of Contents * [Chapter 1](#chapter-1) * [Chapter 2](#chapter-2) * [Chapter 3](#chapter-3) 将跳转到这些部分： ## Chapter 1 \u003ca id=\"chapter-1\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 2 \u003ca id=\"chapter-2\"\u003e\u003c/a\u003e Content for chapter one. ## Chapter 3 \u003ca id=\"chapter-3\"\u003e\u003c/a\u003e Content for chapter one. 注意 定位标记的位置几乎是任意的。因为它们并不引人注目，所以它们通常被放在同一行了。 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:11:3","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"12 脚注 脚注使你可以添加注释和参考，而不会使文档正文混乱。 当你创建脚注时，会在添加脚注引用的位置出现带有链接的上标编号。 读者可以单击链接以跳至页面底部的脚注内容。 要创建脚注引用，请在方括号中添加插入符号和标识符 ([^1])。 标识符可以是数字或单词，但不能包含空格或制表符。 标识符仅将脚注引用与脚注本身相关联 - 在脚注输出中，脚注按顺序编号。 在中括号内使用插入符号和数字以及用冒号和文本来添加脚注内容 ([^1]：这是一段脚注)。 你不一定要在文档末尾添加脚注。可以将它们放在除列表，引用和表格等元素之外的任何位置。 这是一个数字脚注 [^1] 这是一个带标签的脚注 [^label] [^1]: 这是一个数字脚注 [^label]: 这是一个带标签的脚注 这是一个数字脚注 1 这是一个带标签的脚注 2 ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:12:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":["Markdown"],"content":"13 图片 图片的语法与链接相似，但包含一个在前面的感叹号。 ![Minion](https://octodex.github.com/images/minion.png) 或者： ![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\") The StormtroopocatAlt text \" The Stormtroopocat 像链接一样，图片也具有脚注样式的语法： ![Alt text][id] The DojocatAlt text \" The Dojocat 稍后在文档中提供参考内容，用来定义 URL 的位置： [id]: https://octodex.github.com/images/dojocat.jpg \"The Dojocat\" 技巧 FixIt 主题提供了一个包含更多功能的 图片的 shortcode. 这是一个数字脚注 ↩︎ 这是一个带标签的脚注 ↩︎ ","date":"2019-12-01","objectID":"/basic-markdown-syntax/:13:0","tags":["Markdown"],"title":"Markdown 基本语法","uri":"/basic-markdown-syntax/"},{"categories":null,"content":"工作经历 2021.02-至今 携程 系统研发部 软件技术专家 工程效率团队负责人 2018.02-2021.01 携程 系统研发部 资深软件工程师 工程效率团队负责人 2015.02-2018.01 携程 系统研发部 高级软件工程师 2014.04-2015.01 携程 系统研发部 软件工程师 ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"关注领域 持续集成、持续交付 软件配置管理 云原生 ","date":"0001-01-01","objectID":"/about/:2:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Hugo FixIt 主题的友链模板 Demo","date":"0001-01-01","objectID":"/friends/","tags":null,"title":"友情链接","uri":"/friends/"},{"categories":null,"content":"基本信息 - nickname:菠菜眾長avatar:https://lruihao.cn/images/avatar.jpgurl:https://lruihao.cndescription:李瑞豪的博客 ","date":"0001-01-01","objectID":"/friends/:1:0","tags":null,"title":"友情链接","uri":"/friends/"},{"categories":null,"content":"友情提醒 Notice 互换友链请按以上格式在评论留言。（仅限个人非商业博客/网站） 提醒：网站失效、停止维护、内容不当都可能被取消连接！ 那些不尊重他人劳动成果，转载不加出处的，或恶意行为的网站，还请您不要来进行交换了。 ","date":"0001-01-01","objectID":"/friends/:2:0","tags":null,"title":"友情链接","uri":"/friends/"}]